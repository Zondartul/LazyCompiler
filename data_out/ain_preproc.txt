#file "data_in/lazy2.txt"
#line 1
#file "data_in/big/unit_tests.txt"
#line 1
/// Unit test for LazyTongue 
/// PS: because pointers are hard-coded, this should be the first include file in main.lz
//int tests[10];
int CODE_OK = -1;
int TYPE_BASIC = 1;
int TYPE_STACK = 2;
int TYPE_GLOBAL = 3;
int unit_test_ignore_global_address = 0;
int unit_test_ignore_stack_address = 0;
int unit_test_adaptive_stack = 1;
int unit_test_stack_offset = 0;

#file "data_in/big/string.txt"
#line 1
int strlen(char *str)
	int i = 0;
	while(*str++) i++; end
	return i;
end

void string_reverse(char *str)
	int len = strlen(str);
	for(int i = 0; i < len/2; i++)
		int opposite = len-1-i;
		char d = str[i];
		str[i] = str[opposite];
		str[opposite] = d;
	end	
end

void memmove(char *dest, char *src, int size)
	if(dest > src)
		//print(".moveback.");
		for(int i = size-1; i > -1; i--)
			dest[i] = src[i];
		end
		for(int i = 0; i < size; i++)
			dest[i] = 'w';
		end
	end
	if(dest < src)
		writePort(3,2);
		for(int i = 0; i < size; i++)
			dest[i] = src[i];
		end
	end
end

void strmove(char *dest, char *src)
	int len = strlen(src);
	memmove(dest, src, len+1); //includes terminating zero
end


//if the string is shorter than padlen, pads in with padchar
void strPadBegin(char *str, int padlen, char padchar)
	int len = strlen(str);
	if(len < padlen)
		int diff = padlen - len;
		strmove(str+diff, str);
		for(int i = 0; i < diff; i++)
			str[i] = padchar;
		end
	end
end

void strPadEnd(char *str, int padlen, char padchar)
	int len = strlen(str);
	if(len < padlen)
		int diff = padlen - len;
		for(int i = 0; i < diff; i++)
			str[len+i] = padchar;
		end
		str[padlen] = 0;
	end
end
#file "data_in/big/unit_tests.txt"
#line 14

/// tests:
/// 1 - plain arguments
/// 2 - global vars
/// 3 - pointer (val, &val, *val)
/// 4 - funcptr
/// 5 - auto unit test

void test_1_args_plain()
	test_1_args_plain_helper(1, 2, 3);	
end

void test_1_args_plain_helper(int x, int y, int z)
	writePort(0, 1);
	if((x == 1) & (y == 2) & (z == 3))
		return;
	end
	crash();
end

int test_2_var = 123;
void test_2_global_vars()
	expect(2,1,test_2_var, 123, TYPE_BASIC);
	test_2_var = 234;
	expect(2,2,test_2_var, 234, TYPE_BASIC);
	test_2_var = 123;
end

void test_3_pointer()
	test_3_local_pointer();
	test_3_global_pointer();
	test_3_array_pointer();
end

void test_3_local_pointer()
	int derp = 6;
	expect(3, 1, derp,      6, TYPE_BASIC);
	expect(3, 2, &derp,    -5, TYPE_STACK);
	int *p = derp; /// *derp is forbidden by compiler
	expect(3, 3, p,         6, TYPE_BASIC); 
	expect(3, 4, *p,       14, TYPE_GLOBAL);
end

int test3_var = 7;
void test_3_global_pointer()
	expect(3, 5, test3_var,      7, TYPE_BASIC);
	expect(3, 6, &test3_var, 12402, TYPE_GLOBAL);
	int *p = test3_var; /// *test3_var is forbidden by compiler
	expect(3, 7, *p, 25, TYPE_GLOBAL);
end

int *arr_addr = 0;
void test_3_array_pointer()
	int arr[4];
	arr[0] = 10;
	arr[1] = 11;
	arr[2] = 12;
	arr[3] = 13;
	arr_addr = arr;
	expect(3, 8, arr,    -8, TYPE_STACK);
	expect(3, 9,  arr[0], 10, TYPE_BASIC);
	expect(3, 10, arr[2], 12, TYPE_BASIC);
	expect(3, 11, arr_addr[2], 12, TYPE_BASIC);
	int d = arr[1];
	expect(3, 12, d, 11);
	test_3_array_arg(arr);
end

void test_3_array_arg(int* arg)
	expect(3, 13, arg,arr_addr, TYPE_BASIC);
	expect(3, 14, arg,      -8, TYPE_STACK);
	expect(3, 15, &arg,    -27, TYPE_STACK);
	expect(3, 16, arg[2],   12, TYPE_BASIC);
	expect(3, 17, *arg,     10, TYPE_BASIC);
	expect(3, 18, *(arg+1), 11, TYPE_BASIC);
end

int test_4_var = 0;
int test_4_helper()
	test_4_var = 1;
	return 10;
end

int test_4_funcptr()
	expect(4, 1, test_4_helper,  1098, TYPE_GLOBAL);
	//expect(4, 2, &test_4_helper, 1098, TYPE_GLOBAL);
	int *p1 = test_4_helper;
	int p2 = test_4_helper;
	expect(4, 3, p1,             1098, TYPE_GLOBAL);
	expect(4, 4, p2,             1098, TYPE_GLOBAL);
	int res = p1();
	expect(4, 5, res,              10, TYPE_BASIC);
	expect(4, 6, test_4_var,        1, TYPE_BASIC); ///ps: missing semicolon here is reported as "no source text"
	return CODE_OK;
end

int test_5_arithmetic()
	test_5_arithmetic_integer();
end

int test_5_arithmetic_integer()
	int x = 10;
	int y = 20;

	expect(5,  1, x+y, 30,  TYPE_BASIC);
	expect(5,  2, x-y, -10, TYPE_BASIC);
	expect(5,  3, x*y, 200, TYPE_BASIC);
	expect(5,  4, x/y, 0,   TYPE_BASIC);
	expect(5,  5, y/x, 2,   TYPE_BASIC);
	expect(5,  6, x>y, 0,   TYPE_BASIC);
	expect(5,  7, x<y, 1,   TYPE_BASIC);
	expect(5,  8, y<x, 0,   TYPE_BASIC);
	expect(5,  9, y>x, 1,   TYPE_BASIC);
	expect(5, 10, x==y, 0,  TYPE_BASIC);
	expect(5, 11, x!=y, 1,  TYPE_BASIC);
	expect(5, 12, x&y, 1,   TYPE_BASIC);
	expect(5, 13, x|y, 1,   TYPE_BASIC);
	expect(5, 14, !x, 0,    TYPE_BASIC);
	expect(5, 15, !!x, 1,   TYPE_BASIC);
	
	return CODE_OK;
end

void set_buff_mario(char *buff)
	buff[0] = 'm';
	buff[1] = 'a';
	buff[2] = 'r';
	buff[3] = 'i';
	buff[4] = 'o';
	buff[5] = 0;
end

void set_buff_warudo(char *buff)
	buff[0] = 'w';
	buff[1] = 'a';
	buff[2] = 'r';
	buff[3] = 'u';
	buff[4] = 'd';
	buff[5] = 'o';
	buff[6] = 0;
end

int test_6_arrays()
	int arr[10];
	writePort(7, 19999);
	set_buff_mario(arr);		// pass array by pointer
	/// arr == {mario}
	expect(6, 1, arr[0], 'm',   TYPE_BASIC);
	expect(6, 2, *arr, 'm',     TYPE_BASIC);	// array is filled through literal index
	expect(6, 3, arr[1], 'a',   TYPE_BASIC);
	expect(6, 4, arr[2], 'r',   TYPE_BASIC);
	expect(6, 5, arr[3], 'i',   TYPE_BASIC);
	expect(6, 6, arr[4], 'o',   TYPE_BASIC);
	expect(6, 7, arr[5], 0,     TYPE_BASIC);	// array is zero-terminated
	int i = 1;
	arr[i] = 'o';	
	/// arr == {morio}			
	expect(6, 8, arr[1], 'o',   TYPE_BASIC);	// array is writeable by local var index
	expect(6, 9, arr[i], 'o',   TYPE_BASIC);	// array is readible by local var index
	int b1 = (&(arr[i]) == arr+i); // index is a (PTR or LVAL) whose address is equivalent to a sum of PTR+RVAL
	expect(6, 10, b1, 1);		
	arr[i+2] = 'e';	// array is writeable by arithmetic expression
	/// arr == {moreo}
	expect(6, 11, arr[3], 'e',  TYPE_BASIC);
	expect(6, 12, arr[i+3], 'o',TYPE_BASIC);	// array is readible by arithmetic expression

	int L = strlen(arr);
	expect(6, 13, L, 5);			// stdlib function "strlen" works

	int arr2[20];
	set_buff_warudo(arr2);			// another test buffer
	/// arr  == {moreo\0}
	/// arr2 == {warudo\0}
	expect(6, 14, arr2[0], 'w', TYPE_BASIC);
	expect(6, 15, arr2[1], 'a', TYPE_BASIC);
	expect(6, 16, arr2[2], 'r', TYPE_BASIC);
	expect(6, 17, arr2[3], 'u', TYPE_BASIC);
	expect(6, 18, arr2[4], 'd', TYPE_BASIC);
	expect(6, 19, arr2[5], 'o', TYPE_BASIC);
	expect(6, 20, arr2[6], 0,   TYPE_BASIC);

	memmove(arr2, arr, L+1);
	/// arr  == {moreo\0}
	/// arr2 == {moreo\0\0}
	expect(6, 21, arr2[0], 'm', TYPE_BASIC); // stdlib function "memmove" works
	expect(6, 22, arr2[1], 'o', TYPE_BASIC);
	expect(6, 23, arr2[2], 'r', TYPE_BASIC);
	expect(6, 24, arr2[3], 'e', TYPE_BASIC);
	expect(6, 25, arr2[4], 'o', TYPE_BASIC);
	expect(6, 26, arr2[5], 0,   TYPE_BASIC);
	expect(6, 27, arr2[6], 0,   TYPE_BASIC);
end

/*
class Test_7_class_derp //class Derp
	int x = 1;
	int y;
	int sum(int z)
		int w = x+y+z;
		return w;
	end
	int test71()
		printf("derp.t71:  x = %d\n", x);
		printf("derp.t71: &x = %d\n", &x);
		printf("derp.t71: this = %d\n", this);
		printf("derp.t71: y1 = %d\n", y);
		y = 3;
		printf("derp.t71: y2 = %d\n", y);
	end
end

int test_7_class_local()
	class Test_7_class_derp derp1;
	printf("test7: &derp1 = %d\n", &derp1);
	printf("test7: &(derp1.x) = %d\n", &(derp1.x));
	printf("test7: derp1.x = %d\n", derp1.x);
	derp1.test71();
	expect(7, 1, &derp1,		-28, TYPE_STACK);
	expect(7, 2, derp1.x,		  1, TYPE_BASIC);
	derp1.y = 2;
	expect(7, 3, derp1.y,		  2, TYPE_BASIC);
	expect(7, 4, derp1.sum(4),	  7, TYPE_BASIC);
	expect(7, 5, &derp1.sum,   2496, TYPE_GLOBAL);
	return CODE_OK;
end

int test_7_class_by_val(class Test_7_class_derp derp2)
	expect(7, 6, &derp2,		-25, TYPE_STACK);
	expect(7, 7, derp2.x,		  3, TYPE_BASIC);
	expect(7, 8, derp2.y,		  4, TYPE_BASIC);
	expect(7, 9, derp2.sum(5),   12, TYPE_BASIC);
	expect(7, 10, &derp2.sum,  2496, TYPE_GLOBAL);
	return CODE_OK;
end

int test_7_class_by_ptr(class Test_7_class_derp *derp3)
	expect(7, 11, derp3,		 -3, TYPE_STACK);
	expect(7, 12, &derp3,	    -25, TYPE_STACK);
	expect(7, 13, derp3.x,		  5, TYPE_BASIC);
	expect(7, 14, derp3.y,		  6, TYPE_BASIC);
	expect(7, 15, derp3.sum(7),	 18, TYPE_BASIC);
	expect(7, 16, &derp3.sum,  2496, TYPE_GLOBAL);
	return CODE_OK;
end

int test_7_class()
	test_7_class_local();
	class Test_7_class_derp derp4;
	derp4.x = 3; derp4.y = 4;
	test_7_class_by_val(derp4);
	class Test_7_class_derp derp5;
	derp5.x = 5; derp5.y = 6;
	test_7_class_by_ptr(&derp5);
	return CODE_OK;
end
*/

void expect(int test_num,int subtest_num, int val, int ref, int type)
	if ((type == TYPE_STACK) & unit_test_ignore_stack_address) return; end
	if ((type == TYPE_GLOBAL) & unit_test_ignore_global_address) return; end
	writePort(0, test_num);
	writePort(1, subtest_num);
	if (type == TYPE_STACK && unit_test_adaptive_stack) val = val - unit_test_stack_offset; end
	writePort(2, val);
	writePort(3, ref);
	if(val != ref) crash(); end
end

void report_all_ok()
	writePort(0, -1);
	writePort(1, -1);
	writePort(2, -1);
	writePort(3, -1);	
end

void unit_test_set_base_offset()
	int base = 0;
	unit_test_stack_offset = &base;
end

void run_all_tests()
	unit_test_ignore_global_address = 1;
	unit_test_ignore_stack_address = 1;
	unit_test_adaptive_stack = 1;
	
	unit_test_set_base_offset();
	test_1_args_plain();
	test_2_global_vars();
	test_3_pointer();
	test_4_funcptr();
	test_5_arithmetic();
	test_6_arrays();
	unit_test_ignore_global_address = 0;
	//test_7_class();
	report_all_ok();
end


#file "data_in/lazy2.txt"
#line 2
#file "data_in/big/testOutput.txt"
#line 1
void infloop() while(1) end end

int *adr_port = 65536;

void writePort(int port, int val)
	*(adr_port+port) = val;
end

void resetPorts()
	writePort(0, 9999);
	writePort(1, 9999);
	writePort(2, 9999);
	writePort(3, 9999);
	writePort(4, 9999);
	writePort(5, 9999);
	writePort(6, 9999);
	writePort(7, 9999);
end

void setup()
	//screen_set(65536+100);
	//screen_clear();
	//libprints_init();
	resetPorts();
end

void crash()
	int x = 1;
	x = x/0;
end

void delay(int n) for(int i = 0; i < n; i++) end end
#file "data_in/lazy2.txt"
#line 3
//#include "data_in/big/printf.txt"

/*
int addr_bus[4];


void stuff_test_1()
	int x;
	printf("t1 x1: %d\n", x); // ???
	x = 11;
	printf("t1 x2: %d\n", x); // 11
end



void init_printf()
	addr_bus[0] = 65536;
	addr_bus[1] = addr_bus[0] + 20000;
	addr_bus[2] = addr_bus[1] + 20000;
	addr_bus[3] = addr_bus[2] + 20000;
	screen_set(addr_bus[2]);

	screen_clear();
end

void test_printf()
	printf("hello world!\n");
	/// todo: uhh, constructor of derp initializes it to 10 instead of 1 (test61)
	/// oh hey, it turns out our printf or num2str doesn't flip the digits oops
	//printf("123[%d],45[%d],1[%d],10[%d],0.1[%d]\n",123,45,1,10,1/10);
	// bluuuuh, nothing but %d works on printf and even that crappily backwards
	printf("s test: %s\n","abra_cadabra_karabas_barabas");
	printf("d test: %d, %d, %d\n", 123, 45, 1907);
	char *str = "[my string]";
	int L = strlen(str);
	printf("strlen = %d\n", L);

	printf(str);
	char zuzubaf[20];
	set_buff_mario(zuzubaf);
	debug_s_arg(zuzubaf); printf("\n");
	memmove(zuzubaf, str, L+1);
	debug_s_arg(zuzubaf); printf("\n");
	printf("str : [");printf(str);printf("]\n");
	printf("buff: [");printf(zuzubaf);printf("]\n");
	debug_s_arg(zuzubaf); printf("\n");
	return;

	int x = 10;
	printf("t0 x1: %d\n", x); // 10
	char buff2[7];
	set_buff_warudo(buff2);
	debug_s_arg(buff2);
	stuff_test_1();
	stuff_test_2();
	printf("t0 x2: %d\n", x); // 10
	debug_s_arg(buff2);
	//printf("\n");
	//printf("before: %s\n",str);
	//string_reverse(str);
	//printf("after : %s\n",str);
	//printf(str);
	//printf("\n");
end

void stuff_test_2()
	int x;
	printf("t2 x1: %d\n", x); // ???
	x = 12;
	printf("t2 x2: %d\n", x); // 12
end
*/
/*
int *adr_port = 65536;

void writePort(int port, int val)
	*(adr_port+port) = val;
end
*/

int main()
	setup();
	
	//init_printf();
	
	run_all_tests();
	
	infloop();
end
