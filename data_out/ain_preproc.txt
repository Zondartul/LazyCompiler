#file "data_in/lazy2.txt"
#line 1
#file "data_in/big/unit_tests.txt"
#line 1
/// Unit test for LazyTongue 
/// PS: because pointers are hard-coded, this should be the first include file in main.lz
//int tests[10];
int CODE_OK = -1;
int TYPE_BASIC = 1;
int TYPE_STACK = 2;
int TYPE_GLOBAL = 3;
int unit_test_ignore_global_address = 0;
int unit_test_ignore_stack_address = 0;
int unit_test_adaptive_stack = 1;
int unit_test_stack_offset = 0;

#file "data_in/big/string.txt"
#line 1
int strlen(char *str)
	int i = 0;
	while(*str++) i++; end
	return i;
end

void string_reverse(char *str)
	int len = strlen(str);
	for(int i = 0; i < len/2; i++)
		int opposite = len-1-i;
		char d = str[i];
		str[i] = str[opposite];
		str[opposite] = d;
	end	
end

void memmove(char *dest, char *src, int size)
	if(dest > src)
		//print(".moveback.");
		for(int i = size-1; i > -1; i--)
			dest[i] = src[i];
		end
		//for(int i = 0; i < size; i++)
		//	dest[i] = 'w';
		//end
	end
	if(dest < src)
		//writePort(3,2);
		for(int i = 0; i < size; i++)
			dest[i] = src[i];
		end
	end
end

void strmove(char *dest, char *src)
	int len = strlen(src);
	memmove(dest, src, len+1); //includes terminating zero
end


//if the string is shorter than padlen, pads in with padchar
void strPadBegin(char *str, int padlen, char padchar)
	int len = strlen(str);
	if(len < padlen)
		int diff = padlen - len;
		strmove(str+diff, str);
		for(int i = 0; i < diff; i++)
			str[i] = padchar;
		end
	end
end

void strPadEnd(char *str, int padlen, char padchar)
	int len = strlen(str);
	if(len < padlen)
		int diff = padlen - len;
		for(int i = 0; i < diff; i++)
			str[len+i] = padchar;
		end
		str[padlen] = 0;
	end
end
#file "data_in/big/unit_tests.txt"
#line 14

/// tests:
/// 1 - plain arguments
/// 2 - global vars
/// 3 - pointer (val, &val, *val)
/// 4 - funcptr
/// 5 - auto unit test

void test_1_args_plain()
	test_1_args_plain_helper(1, 2, 3);	
end

void test_1_args_plain_helper(int x, int y, int z)
	writePort(0, 1);
	if((x == 1) & (y == 2) & (z == 3))
		return;
	end
	crash();
end

int test_2_var = 123;
void test_2_global_vars()
	expect(2,1,test_2_var, 123, TYPE_BASIC);
	test_2_var = 234;
	expect(2,2,test_2_var, 234, TYPE_BASIC);
	test_2_var = 123;
end

void test_3_pointer()
	test_3_local_pointer();
	test_3_global_pointer();
	test_3_array_pointer();
end

void test_3_local_pointer()
	int derp = 6;
	expect(3, 1, derp,      6, TYPE_BASIC);
	expect(3, 2, &derp,    -5, TYPE_STACK);
	int *p = derp; /// *derp is forbidden by compiler
	expect(3, 3, p,         6, TYPE_BASIC); 
	expect(3, 4, *p,       14, TYPE_GLOBAL);
end

int test3_var = 7;
void test_3_global_pointer()
	expect(3, 5, test3_var,      7, TYPE_BASIC);
	expect(3, 6, &test3_var, 12402, TYPE_GLOBAL);
	int *p = test3_var; /// *test3_var is forbidden by compiler
	expect(3, 7, *p, 25, TYPE_GLOBAL);
end

int *arr_addr = 0;
void test_3_array_pointer()
	int arr[4];
	arr[0] = 10;
	arr[1] = 11;
	arr[2] = 12;
	arr[3] = 13;
	arr_addr = &arr;
	expect(3, 8,  &arr,   -8, TYPE_STACK);
	expect(3, 9,  arr[0], 10, TYPE_BASIC);
	expect(3, 10, arr[2], 12, TYPE_BASIC);
	expect(3, 11, arr_addr[2], 12, TYPE_BASIC);
	int d = arr[1];
	expect(3, 12, d, 11);
	test_3_array_arg(&arr); // array-by-ptr
	// btw now we also need to test array-by-val
end

void test_3_array_arg(int* arg)
	expect(3, 13, arg,arr_addr, TYPE_BASIC);
	expect(3, 14, arg,      -8, TYPE_STACK);
	expect(3, 15, &arg,    -27, TYPE_STACK);
	expect(3, 16, arg[2],   12, TYPE_BASIC);
	expect(3, 17, *arg,     10, TYPE_BASIC);
	expect(3, 18, *(arg+1), 11, TYPE_BASIC);
end

int test_4_var = 0;
int test_4_helper()
	test_4_var = 1;
	return 10;
end

int test_4_funcptr()
	expect(4, 1, test_4_helper,  1098, TYPE_GLOBAL);
	//expect(4, 2, &test_4_helper, 1098, TYPE_GLOBAL);
	int *p1 = test_4_helper;
	int p2 = test_4_helper;
	expect(4, 3, p1,             1098, TYPE_GLOBAL);
	expect(4, 4, p2,             1098, TYPE_GLOBAL);
	int res = p1();
	expect(4, 5, res,              10, TYPE_BASIC);
	expect(4, 6, test_4_var,        1, TYPE_BASIC); ///ps: missing semicolon here is reported as "no source text"
	return CODE_OK;
end

int test_5_arithmetic()
	test_5_arithmetic_integer();
end

int test_5_arithmetic_integer()
	int x = 10;
	int y = 20;

	expect(5,  1, x+y, 30,  TYPE_BASIC);
	expect(5,  2, x-y, -10, TYPE_BASIC);
	expect(5,  3, x*y, 200, TYPE_BASIC);
	expect(5,  4, x/y, 0,   TYPE_BASIC);
	expect(5,  5, y/x, 2,   TYPE_BASIC);
	expect(5,  6, x>y, 0,   TYPE_BASIC);
	expect(5,  7, x<y, 1,   TYPE_BASIC);
	expect(5,  8, y<x, 0,   TYPE_BASIC);
	expect(5,  9, y>x, 1,   TYPE_BASIC);
	expect(5, 10, x==y, 0,  TYPE_BASIC);
	expect(5, 11, x!=y, 1,  TYPE_BASIC);
	expect(5, 12, x&y, 1,   TYPE_BASIC);
	expect(5, 13, x|y, 1,   TYPE_BASIC);
	expect(5, 14, !x, 0,    TYPE_BASIC);
	expect(5, 15, !!x, 1,   TYPE_BASIC);
	
	return CODE_OK;
end

void set_buff_mario(char *buff)
	buff[0] = 'm';
	buff[1] = 'a';
	buff[2] = 'r';
	buff[3] = 'i';
	buff[4] = 'o';
	buff[5] = 0;
end

void set_buff_warudo(char *buff)
	buff[0] = 'w';
	buff[1] = 'a';
	buff[2] = 'r';
	buff[3] = 'u';
	buff[4] = 'd';
	buff[5] = 'o';
	buff[6] = 0;
end

int test_6_arrays()
	int arr[10];
	set_buff_mario(&arr);		// pass array by pointer
	/// arr == {mario}
	expect(6, 1, arr[0], 'm',   TYPE_BASIC);
	expect(6, 2, *arr, 'm',     TYPE_BASIC);	// array is filled through literal index
	expect(6, 3, arr[1], 'a',   TYPE_BASIC);
	expect(6, 4, arr[2], 'r',   TYPE_BASIC);
	expect(6, 5, arr[3], 'i',   TYPE_BASIC);
	expect(6, 6, arr[4], 'o',   TYPE_BASIC);
	expect(6, 7, arr[5], 0,     TYPE_BASIC);	// array is zero-terminated
	int i = 1;
	arr[i] = 'o';	
	/// arr == {morio}			
	expect(6, 8, arr[1], 'o',   TYPE_BASIC);	// array is writeable by local var index
	expect(6, 9, arr[i], 'o',   TYPE_BASIC);	// array is readible by local var index
	int b1 = (&(arr[i]) == arr+i); // index is a (PTR or LVAL) whose address is equivalent to a sum of PTR+RVAL
	expect(6, 10, b1, 1);		
	arr[i+2] = 'e';	// array is writeable by arithmetic expression
	/// arr == {moreo}
	expect(6, 11, arr[3], 'e',  TYPE_BASIC);
	expect(6, 12, arr[i+3], 'o',TYPE_BASIC);	// array is readible by arithmetic expression

	int L = strlen(&arr);
	expect(6, 13, L, 5);			// stdlib function "strlen" works

	int arr2[20];
	set_buff_warudo(&arr2);			// another test buffer
	/// arr  == {moreo\0}
	/// arr2 == {warudo\0}
	expect(6, 14, arr2[0], 'w', TYPE_BASIC);
	expect(6, 15, arr2[1], 'a', TYPE_BASIC);
	expect(6, 16, arr2[2], 'r', TYPE_BASIC);
	expect(6, 17, arr2[3], 'u', TYPE_BASIC);
	expect(6, 18, arr2[4], 'd', TYPE_BASIC);
	expect(6, 19, arr2[5], 'o', TYPE_BASIC);
	expect(6, 20, arr2[6], 0,   TYPE_BASIC);

	memmove(&arr2, &arr, L+1);
	/// arr  == {moreo\0}
	/// arr2 == {moreo\0\0}
	expect(6, 21, arr2[0], 'm', TYPE_BASIC); // stdlib function "memmove" works
	expect(6, 22, arr2[1], 'o', TYPE_BASIC);
	expect(6, 23, arr2[2], 'r', TYPE_BASIC);
	expect(6, 24, arr2[3], 'e', TYPE_BASIC);
	expect(6, 25, arr2[4], 'o', TYPE_BASIC);
	expect(6, 26, arr2[5], 0,   TYPE_BASIC);
	expect(6, 27, arr2[6], 0,   TYPE_BASIC);
end


class Test_7_class_derp //class Derp
	int x = 1;
	int y;
	int sum(int z)
		int w = x+y+z;
		return w;
	end
	int test71()
		printf("derp.t71:  x = %d\n", x);
		printf("derp.t71: &x = %d\n", &x);
		printf("derp.t71: this = %d\n", this);
		printf("derp.t71: y1 = %d\n", y);
		y = 3;
		printf("derp.t71: y2 = %d\n", y);
	end
	int set_y(int new_y)
		y = new_y;
	end
	int report_y()
		printf("derp.ry: y = %d\n", y);	
	end
end

int test_7_class_local()
	class Test_7_class_derp derp1;
	printf("test7: &derp1 = %d\n", &derp1);
	printf("test7: &(derp1.x) = %d\n", &(derp1.x));
	printf("test7: derp1.x = %d\n", derp1.x);
	derp1.test71();
	expect(7, 1, &derp1,		-23, TYPE_STACK);
	derp1.y = 12;
	expect(7, 2, derp1.y,	     12, TYPE_BASIC);
	derp1.report_y();
	derp1.set_y(4);
	expect(7, 3, derp1.y,		  4, TYPE_BASIC);
	expect(7, 4, derp1.x,		  1, TYPE_BASIC);
	expect(7, 5, derp1.sum(4),	  9, TYPE_BASIC);
	//expect(7, 5, &(derp1.sum),   2496, TYPE_GLOBAL); // semantic error: function is already an address
	//expect(7, 5, &derp1.sum,   2496, TYPE_GLOBAL);   // semantic error: function is already an address
	expect(7, 6, derp1.sum,    4573, TYPE_GLOBAL);
	return CODE_OK;
end

int test_7_class_by_val(class Test_7_class_derp derp2)
	writePort(6, 199999);
	expect(7, 7, &derp2,		 -21, TYPE_STACK);
	expect(7, 8, derp2.x,		  3, TYPE_BASIC);
	expect(7, 9, derp2.y,		  4, TYPE_BASIC);
	expect(7, 10, derp2.sum(5),  12, TYPE_BASIC);
	expect(7, 11, derp2.sum,   4573, TYPE_GLOBAL);
	return CODE_OK;
end

int test_7_class_by_ptr(class Test_7_class_derp *derp3)
	expect(7, 12, derp3,		 -3, TYPE_STACK);
	expect(7, 13, &derp3,	     -20, TYPE_STACK);
	expect(7, 14, (*derp3).x,	  5, TYPE_BASIC);
	expect(7, 15, derp3.x,		  5, TYPE_BASIC);
	expect(7, 16, derp3.y,		  6, TYPE_BASIC);
	expect(7, 17, derp3.sum(7),	 18, TYPE_BASIC);
	expect(7, 18, derp3.sum,   4573, TYPE_GLOBAL);
	return CODE_OK;
end

class Test_7_class_derp derp4;

int test_7_class_global()
	expect(7, 19, &derp4,	  999, TYPE_GLOBAL);
	void *p1 = &derp4;
	expect(7, 20, p1,		  999, TYPE_GLOBAL);
	void *px = &(derp4.x);
	void *py = &(derp4.y);
	int b1 = (p1 == px);
	int b2 = ((p1 + 1) == py);
	expect(7, 21, b1, 			1, TYPE_BASIC);
	expect(7, 22, b2,			1, TYPE_BASIC);
	expect(7, 23, *px,			1, TYPE_BASIC);
	expect(7, 24, derp4.x,		1, TYPE_BASIC);
	derp4.y = 4;
	expect(7, 25, *py,			4, TYPE_BASIC);
	expect(7, 26, derp4.y,		4, TYPE_BASIC);
	expect(7, 27, derp4.sum(10),15,TYPE_BASIC);
	return CODE_OK;
end

int test_7_class()
	test_7_class_local();
	class Test_7_class_derp derp4;
	derp4.x = 3; derp4.y = 4;
	test_7_class_by_val(derp4);
	class Test_7_class_derp derp5;
	derp5.x = 5; derp5.y = 6;
	test_7_class_by_ptr(&derp5);
	test_7_class_global();
	return CODE_OK;
end


void expect(int test_num,int subtest_num, int val, int ref, int type)
	if ((type == TYPE_STACK) & unit_test_ignore_stack_address) return; end
	if ((type == TYPE_GLOBAL) & unit_test_ignore_global_address) return; end
	writePort(0, test_num);
	writePort(1, subtest_num);
	if (type == TYPE_STACK && unit_test_adaptive_stack) val = val - unit_test_stack_offset; end
	writePort(2, val);
	writePort(3, ref);
	if(val != ref) crash(); end
end

void report_all_ok()
	writePort(0, -1);
	writePort(1, -1);
	writePort(2, -1);
	writePort(3, -1);	
end

void unit_test_set_base_offset()
	int base = 0;
	unit_test_stack_offset = &base;
	writePort(7, unit_test_stack_offset);
end

void run_all_tests()
	unit_test_ignore_global_address = 1;
	unit_test_ignore_stack_address = 1;
	unit_test_adaptive_stack = 1;
	
	unit_test_set_base_offset();
	test_1_args_plain();
	test_2_global_vars();
	test_3_pointer();
	test_4_funcptr();
	test_5_arithmetic();
	test_6_arrays();
	//unit_test_ignore_global_address = 0;
	//unit_test_ignore_stack_address = 0;
	test_7_class();
	report_all_ok();
end


#file "data_in/lazy2.txt"
#line 2
#file "data_in/big/testOutput.txt"
#line 1
void infloop() while(1) end end

int *adr_port = 65536;

void writePort(int port, int val)
	*(adr_port+port) = val;
end

void resetPorts()
	writePort(0, 9999);
	writePort(1, 9999);
	writePort(2, 9999);
	writePort(3, 9999);
	writePort(4, 9999);
	writePort(5, 9999);
	writePort(6, 9999);
	writePort(7, 9999);
end

void setup()
	//screen_set(65536+100);
	//screen_clear();
	//libprints_init();
	resetPorts();
end

void crash()
	int x = 1;
	x = x/0;
end

void delay(int n) for(int i = 0; i < n; i++) end end
#file "data_in/lazy2.txt"
#line 3
#file "data_in/big/printf.txt"
#line 1
//hello, am printf
#file "data_in/big/prints.txt"
#line 1
#file "data_in/big/consolescreen.txt"
#line 1
char *AdrScreen = 0;

void printCharXY(int X, int Y, char C, int col)
	int offs = 2*(X+Y*30);
	char *P = AdrScreen + offs;
	P[0] = C;
	P++;
	P[0] = col;
end

void screen_set(char *scr) 
	writePort(5, scr);
	AdrScreen = scr; 
end
void screen_clear() AdrScreen[2041] = 1; end
void screen_cursor_enable() AdrScreen[2046] = 1; end
void screen_cursor_disable() AdrScreen[2046] = 0; end
void screen_set_cursor_pos(int pos) AdrScreen[2045] = 2*pos; end
void screen_set_cursor_pos_xy(int x, int y) AdrScreen[2045] = 2*(30*y+x); end
void screen_force_refresh() AdrScreen[2020] = 1; delay(1); end
void screen_set_shift_box_x1(int n) AdrScreen[2031] = n; end
void screen_set_shift_box_x2(int n) AdrScreen[2032] = n; end
void screen_set_shift_box_y1(int n) AdrScreen[2033] = n; end
void screen_set_shift_box_y2(int n) AdrScreen[2034] = n; end

void screen_set_shift_box(int x1, int x2, int y1, int y2)
	AdrScreen[2031] = x1;
	AdrScreen[2032] = x2;
	AdrScreen[2033] = y1;
	AdrScreen[2034] = y2;
end

void screen_shift_vertical(int n) AdrScreen[2038] = n; end
void screen_shift_horizontal(int n) AdrScreen[2037] = n; end



//void delay(int n) end
#file "data_in/big/prints.txt"
#line 2
#file "data_in/big/number.txt"
#line 1


//returns the (floored) log10 of a number, i.e. number of digits in floor(num).
//assumes num is positive
int ilog10(float num)
	for(int i = 0; i < 10; i++)
		if(num < 10) return i; end
		num = num / 10;
	end
end

//returns 10^num
int ipow10(int num)
	int x = 1;
	for(int i = 0; i < num; i++)
		x = x*10;
	end
	return x;
end

int numDigits(float num) return ilog10(num)+1; end

int getNdigit(float num, int dig)
	//1. remove the lower parts
	num = num / ipow10(dig);
	//2. get the lowest remaining digit
	num = num % 10;
	return num;
end

int floor(float num)
	int res = 0;
	int n = numDigits(num);
	for(int i = 0; i < n; i++)
		int d = getNdigit(num, i);
		res = res + d * ipow10(i);
	end
	return res;
end

int floorPrec(float num, float prec)
	//printf("floorPrec(%d):\n", num);
	int k = ipow10(prec); 	//printf(" ipow10(%d) = %d\n", prec, k);
	num = num * k; 			//printf(" num*k = %d\n", num);
	num = floor(num);		//printf(" floor(num) = %d\n", num);
	num = num / k;			//printf(" num/k = %d\n", num);
	return num;
end

float frac(float num)
	int isNeg = (num < 0);
	if(isNeg) num = -num; end
	float f = num - floor(num);
	if(isNeg) f = -f; end
	return f;
end



void int2str(float num, char *buff)
	char *buffInit = buff;
//	if(num == 0)
//		buff[0] = '0';//*buff++ = '0';
//		buff++;
//		buff[0] = 1;//*buff = 0;
//	end
	int isNeg = 0;
	if(num < 0) isNeg = 1; num = -num; end
	int End = 0;
	while(End==0)
		int d = num % 10;	
		buff[0] = '0'+d;
		buff++;
		num = num / 10;
		
		if(num<1) //if(num == 0)
			if(isNeg) buff[0] = '-'; buff++; end
			buff[0] = 0;
			End = 1;
		end
	end
	string_reverse(buffInit);
end




void float2str(float num, int prec, char *buff)
	char *buffInit = buff;
	int isNeg = (num < 0);
	if(isNeg) num = -num; end
	int num_fl = floor(num);
	float num_fr = frac(num);
	float num_frpr = floorPrec(num_fr, prec);
	//printf("float2str(%d, %d):\n",num, prec);
	//printf("  num_fl = %d\n", num_fl);
	//printf("  num_fr*1000 = %d\n", num_fr*1000);
	//printf("  num_frpr*1000 = %d\n", num_frpr*1000);
	//if(isNeg) *buff++ = '-'; end
	if(isNeg) buff[0] = '-'; buff++; end
	int2str(num_fl, buff);
	buff = buff + strlen(buff);
	//if(num_fr)
		//*buff++ = '.';
		buff[0] = '.';
		buff++;
		int k = ipow10(prec);
		float num_final = floor(num_frpr*k);
		//printf("  num_final = %d\n", num_final);
		int2str(num_final, buff);
		strPadBegin(buff, prec, '0');
	//end
end
#file "data_in/big/prints.txt"
#line 3

int screen_print_x_min = 0;
int screen_print_y_min = 0;
int screen_print_x_max = 30;
int screen_print_y_max = 19;

int cs_last_x = 29;
int cs_last_y = 17;
int printScrX = 0;
int printScrY = 0;

void libprints_init()
	cs_last_x = 29;
	cs_last_y = 17;
	printScrX = 0;
	printScrY = 0;
end

void setPrintCursor(int x, int y) printScrX = x; printScrY = y; end


//idea: functor as 'character inserter'. can check bounds, do /dev/null, etc.
//so basically stream?
int charcode_NL = 10; //same as enter
int charcode_BACK = 13; //same as backspace
int charcode_CR = 14; //same as backspace -> go to prev char or end of prev line
int charcode_FILL = 15; //means "fill the line" (and stop at the last char)
int charcode_BELL = 16; //make a beep or something
//sequences: 
//NL -> print pointer is at the beginning of the next line
//FILL -> line filled with spaces; print pointer at the end of this line
//CR -> print pointer at the beginning of this line
//CR FILL CR -> the line is blank and you are at the beginning
//BACK CR -> go to beginning of prev line
//hello BACK z -> hellz




void PrintChar(char C, int col)
	//dbgprint("printchar ", C, C);
	if(C == charcode_NL) newline(); end
	if(C == charcode_BACK) prevcol(); end
	if(C == charcode_CR) printScrX = 0; end
	if(C == charcode_FILL)
		for(int i = printScrX; i < cs_last_x; i++)
			printCharXY(i, printScrY, ' ', col);
		end
		printScrX = cs_last_x;
	end
	if(C == charcode_BELL) beep(); end
	if(C > 31)
		printCharXY(printScrX, printScrY, C, col);
		newcol();
	end
end


void Prints(char *str2, int col) //maybe str conflicts with the str in print?
	while(*str2)
		PrintChar(*str2++, col);
	end
end

void Printn(int num, int col)
	char buff[20];
	int2str(num, buff);
	Prints(buff, col);
end

void newline()
	printScrX = 0;
	printScrY++;
	if(printScrY > cs_last_y-1)
		ConsoleShiftUp();
	end
end

void prevline()
	printScrX = cs_last_x;
	printScrY--;
	if(printScrY < 0)
		ConsoleShiftDown();
	end
end

void newcol()
	printScrX++;
	if(printScrX > cs_last_x)
		newline();
	end
end

void prevcol()
	printScrX--;
	if(printScrX < 0)
		prevline();
	end
end

void beep() end

void ConsoleShiftUp()
	if(printScrY > cs_last_y-1)
		screen_shift_vertical(1);
		printScrY--;
	end
end

void ConsoleShiftDown()
	if(printScrY < 0)
		screen_shift_vertical(-1);
		printScrY++;
	end
end

void screen_set_print_box(int x1, int y1, int x2, int y2)
	screen_print_x_min = x1;
	screen_print_y_min = y1;
	screen_print_x_max = x2;
	screen_print_y_max = y2;
end
#file "data_in/big/printf.txt"
#line 3

char *lorem_ipsum(int I)
   int sw = I % 10;
   if(sw == 0) return "Lorem ipsum dolor sit amet, "; end
   if(sw == 1) return "consectetur adipiscing elit. "; end
   if(sw == 2) return "Nam auctor lorem in massa tempor bibendum. "; end
   if(sw == 3) return "Nulla in metus in nunc ornare "; end
   if(sw == 4) return "porta ullamcorper non enim. "; end
   if(sw == 5) return "Donec tincidunt magna "; end
   if(sw == 6) return "non tellus blandit faucibus. "; end
   if(sw == 7) return "Nullam ac sem vitae lectus gravida vulputate. "; end
   if(sw == 8) return "Quisque quis lacinia risus, "; end
   if(sw == 9) return "non rutrum turpis. "; end
   return "(oops)";
end

void debug_s_arg(char *arg)
	printf("{s %d}:[",arg);
	while(*arg)
		printf("%c",*arg++);	
	end
	printf("]");
end

int sprintf(char *buff, char *fmt, int *parg)
	int printed = 0;
	while(*fmt)
		char c = *fmt;
		if(c == '%')
			fmt++;
			char c2 = *fmt;
			fmt++;
			if(c2 == 'd') int2str(*parg, buff); parg++; end
			if(c2 == 'f') float2str(*parg, 4, buff); parg++; end
			if(c2 == 's') /*debug_s_arg(*parg);*/ strmove(buff, *parg); parg++; end
			if(c2 == 'c') buff[0] = *parg; parg++; buff[1] = 0; end
			if(c2 == '%') buff[0] = '%'; buff[1] = 0; end
			int inc = strlen(buff);
			printed = printed + inc;
			buff = buff + inc;
		end
		if(c != '%')
			if(c == '\')
				fmt++;
				char c2 = *fmt;
				fmt++;
				if(c2 == 'n') buff[0] = charcode_NL; buff[1] = 0; end
				if(c2 == 'r') buff[0] = charcode_CR; buff[1] = 0; end
				if(c2 == 'f') buff[0] = charcode_FILL; buff[1] = 0; end
				if(c2 == 'b') buff[0] = charcode_BACK; buff[1] = 0; end
				if(c2 == 'e') buff[0] = charcode_BELL; buff[1] = 0; end
				if(c2 == '\') buff[0] = '\'; buff[1] = 0; end
				int inc = strlen(buff);
				printed = printed + inc;
				buff = buff+inc;
			end
			if(c != '\')
				buff[0] = c;
				buff[1] = 0;
				printed++;
				buff++;
				fmt++;
			end
		end
	end
	return printed;
end

int printf(char *fmt, float args)
	int printed = 0;
	char buff[80];
	int *parg = &args;
	printed = sprintf(&buff, fmt, parg);
	Prints(&buff, 999);
	return printed;
end















#file "data_in/lazy2.txt"
#line 4
#file "data_in/big/class_csprinter.txt"
#line 1
// class CSPrinter - handles screen extents and scrolling logic
#file "data_in/big/class_screen.txt"
#line 1
/// driver for a console screen
class CScreen
	char* mem_scr;
	//int X;
	//int Y;
	int x_max;
	int y_max;
	int col;

	void constructor()
		mem_scr = 65536;
		//X = 0;
		//Y = 0;
		x_max = 30;
		y_max = 19;
		col = 999;
		printf("CScreen constructed @ %d\n", this);
	end

	//void incXY()
	//	X++;
	//	if(X > Xmax)
	//		X = 0;
	//		Y++;
	//		if(Y > Ymax)
	//			Y = 0;
	//		end
	//	end
	//end 
 
	void putchXY(char C, int x, int y)
		printf("CScreen.putchXY\n(this %d, C %d, x %d, y %d)\n",this, C, x, y);
		printf("\n x = %d, x_max = %d, y = %d\n", x, x_max, y);
		printf("\nmem_scr = %d\nadr = %d\ntotal offset = %d\n", mem_scr, adr, mem_scr+adr);
		int adr = (x+x_max*y)*2;
		mem_scr[adr] = C;      //this says "array access into non-pointer type char"
		mem_scr[adr+1] = col;
		printf("74.");
	end

	void set(char *scr) 
		//writePort(5, scr);
		mem_scr = scr; 
		printf("set mem_scr to %d, new mem_scr is %d\n", scr, mem_scr);
	end

	void clear() 							mem_scr[2041] = 1; 			end
	void cursor_enable() 					mem_scr[2046] = 1; 			end
	void cursor_disable() 					mem_scr[2046] = 0; 			end
	void set_cursor_pos(int pos) 			mem_scr[2045] = 2*pos; 		end
	void set_cursor_pos_xy(int x, int y) 	mem_scr[2045] = 2*(30*y+x); end
	void force_refresh() 					mem_scr[2020] = 1; delay(1); end
	//void set_shift_box_x1(int n) mem_scr[2031] = n; end
	//void set_shift_box_x2(int n) mem_scr[2032] = n; end
	//void set_shift_box_y1(int n) mem_scr[2033] = n; end
	//void set_shift_box_y2(int n) mem_scr[2034] = n; end

	void set_shift_box(int x1, int x2, int y1, int y2)
		mem_scr[2031] = x1;
		mem_scr[2032] = x2;
		mem_scr[2033] = y1;
		mem_scr[2034] = y2;
	end

	void shift_vertical(int n) 				mem_scr[2038] = n; 			end
	void shift_horizontal(int n) 			mem_scr[2037] = n; 			end

	// general print-some-text stuff
	/*
  void putch(char C)
     putchXY(C, X, Y);
     incXY();
  end 

  void printXY(char *str, int X, int Y)
    while(*str)
       putch(*str++, X++, Y);
    end
  end
 
  void print(char *str)
    while(*str)
       putch(*str++);
    end 
  end
  */
end
#file "data_in/big/class_csprinter.txt"
#line 3

class CSPrinter
	class CScreen *scr = 0;
	
	int box_x_min = 0;
	int box_y_min = 0;
	int box_x_max = 30;
	int box_y_max = 19;

	int last_x = 29;
	int last_y = 17;
	int cur_x = 0;
	int cur_y = 0;

	//void libprints_init()
	//	last_x = 29;
	//	last_y = 17;
	//	cur_x = 0;
	//	cur_y = 0;
	//end

	void init()
		printf("CSPrinter init, this = %d, cur_x before: %d\n", this, cur_x);
		scr = 0;
		box_x_min = 0;
		box_y_min = 0;
		box_x_max = 30;
		box_y_max = 19;
		last_x = 29;
		last_y = 17;
		cur_x = 0;
		cur_y = 0;
		printf("cur_x after: %d\n", cur_x);
	end

	void set_print_cursor(int x, int y) cur_x = x; cur_y = y; end

	int charcode_NL = 10; //same as enter
	int charcode_BACK = 13; //same as backspace
	int charcode_CR = 14; //same as backspace -> go to prev char or end of prev line
	int charcode_FILL = 15; //means "fill the line" (and stop at the last char)
	int charcode_BELL = 16; //make a beep or something
	//sequences: 
	//NL -> print pointer is at the beginning of the next line
	//FILL -> line filled with spaces; print pointer at the end of this line
	//CR -> print pointer at the beginning of this line
	//CR FILL CR -> the line is blank and you are at the beginning
	//BACK CR -> go to beginning of prev line
	//hello BACK z -> hellz

	void putch(char C)		print_char(C, scr.col);		end
	void puts(char *str)	cs_prints(str, scr.col);	end

	void print_char(char C, int col)
		printf("621.");
		if(C == charcode_NL)	cs_newline();	end
		printf("622.");
		if(C == charcode_BACK)	cs_prevcol();	end
		printf("623.");
		if(C == charcode_CR)	cur_x = 0;		end
		printf("624.");
		if(C == charcode_FILL)
		printf("625.");
			for(int i = cur_x; i < last_x; i++)
		printf("626.");
				scr.putchXY(' ', i, cur_y);
		printf("627.");
			end
		printf("628.");
			cur_x = last_x;
		printf("629.");
		end
		printf("62A.");
		if(C == charcode_BELL)	cs_beep();		end
		printf("62B.");
		if(C > 31)
		printf("62C.");
			scr.putchXY(C, cur_x, cur_y);
		printf("62D.");
			cs_newcol();
		printf("62E.");
		end
		printf("62F.");
	end

	void cs_prints(char *str2, int col) //maybe str conflicts with the str in print?
		printf("61.");
		while(*str2)
			printf("62.");
			print_char(*str2++, col);
			printf("63.");	
		end
		printf("63.");
	end

	void cs_printn(int num, int col)
		char buff[20];
		int2str(num, buff);
		cs_prints(buff, col);
	end

	void cs_newline()
		cur_x = 0;
		cur_y++;
		if(cur_y > last_y-1)
			shift_up();
		end
	end

	void cs_prevline()
		cur_x = last_x;
		cur_y--;
		if(cur_y < 0)
			shift_down();
		end
	end

	void cs_newcol()
		cur_x++;
		if(cur_x > last_x)
			newline();
		end
	end

	void cs_prevcol()
		cur_x--;
		if(cur_x < 0)
			prevline();
		end
	end

	void cs_beep() end

	void shift_up()
		if(cur_y > last_y-1)
			scr.shift_vertical(1);
			cur_y--;
		end
	end

	void shift_down()
		if(cur_y < 0)
			scr.shift_vertical(-1);
			cur_y++;
		end
	end

	void set_print_box(int x1, int y1, int x2, int y2)
		box_x_min = x1;
		box_y_min = y1;
		box_x_max = x2;
		box_y_max = y2;
	end
end

#file "data_in/lazy2.txt"
#line 5

int addr_bus[4];

// todo:
//   - array literals {a, b, c}
//   - 



void init_printf()
	addr_bus = {65536, 65536+20000, 65536+20000*2, 65536+20000*3};
	//addr_bus[0] = 65536;
	//addr_bus[1] = addr_bus[0] + 20000;
	//addr_bus[2] = addr_bus[1] + 20000;
	//addr_bus[3] = addr_bus[2] + 20000;
	screen_set(addr_bus[2]);

	screen_clear();
end

//btw you can pass arrays by value now,
// but there is no argument type checking.
// oops....
/*
void test_printf()
	printf("hello world!\n");
	/// todo: uhh, constructor of derp initializes it to 10 instead of 1 (test61)
	/// oh hey, it turns out our printf or num2str doesn't flip the digits oops
	//printf("123[%d],45[%d],1[%d],10[%d],0.1[%d]\n",123,45,1,10,1/10);
	// bluuuuh, nothing but %d works on printf and even that crappily backwards
	printf("s test: %s\n","abra_cadabra_karabas_barabas");
	printf("d test: %d, %d, %d\n", 123, 45, 1907);
	char *str = "[my strings]";
	int L = strlen(str);
	printf("strlen = %d\n", L);

	printf("char C = %c\n", (char)97);

	printf(str);
	char zuzubaf[20];
	set_buff_mario(zuzubaf);
	debug_s_arg(zuzubaf); printf("\n");
	memmove(zuzubaf, str, L+1);
	debug_s_arg(zuzubaf); printf("\n");
	printf("str : [");printf(str);printf("]\n");
	printf("buff: [");printf(zuzubaf);printf("]\n");
	debug_s_arg(zuzubaf); printf("\n");
	return;

	int x = 10;
	printf("t0 x1: %d\n", x); // 10
	char buff2[7];
	set_buff_warudo(buff2);
	debug_s_arg(buff2);
	stuff_test_1();
	stuff_test_2();
	printf("t0 x2: %d\n", x); // 10
	debug_s_arg(buff2);
	//printf("\n");
	//printf("before: %s\n",str);
	//string_reverse(str);
	//printf("after : %s\n",str);
	//printf(str);
	//printf("\n");
end
*/

void stuff_test_2()
	int x;
	printf("t2 x1: %d\n", x); // ???
	x = 12;
	printf("t2 x2: %d\n", x); // 12
end

/*
int *adr_port = 65536;

void writePort(int port, int val)
	*(adr_port+port) = val;
end
*/
/*
int string_pass_test(char* str1, char* str2)
	writePort(0, str1);
	writePort(1, str1[0]);
	writePort(2, str2);
	writePort(3, str2[0]);
end
*/

//btw you can pass arrays by value now,
// but there is no argument type checking.
// oops....


class Dev_address_bus
	int addr[4];
	void constructor(int base_offset, int size1, int size2, int size3)
		addr[0] = base_offset;
		addr[1] = addr[0] + size1;
		addr[2] = addr[1] + size2;
		addr[3] = addr[2] + size3;
		//printf("Dev_address_bus constructed with addr:\n%d, %d, %d, %d\n", addr[0], addr[1], addr[2], addr[3]);
	end
	void write(int dev_num, int* offset, int byte)
		int *ptr = addr[dev_num] + offset;
		//printf("write(*%d) <- %d\n", ptr, byte);
		*ptr = byte;
	end
	int read(int dev_num, int* offset) /// variable was shadowed (addr)
		int *ptr = addr[dev_num] + offset;
		int byte = *ptr;
		//printf("read(*%d) -> %d\n", ptr, byte); 
		return *ptr;
	end
end


class Derp
	int x = 2;
	void constructor(int new_x, int new_y)
		x = new_x+new_y;
		printf("called user constructor:\nnew_x = %d, new_y = %d, x = %d\n",new_x,new_y,x);
	end
end

// -- [CLOSED] bug: can't have same-named method in multiple classes? 
// -- [CLOSED] bug: 'this' passed differently for pointer and real object?
//				nope, works fine, see test_class_multiple_and_ptr

// -- also, zASM fuckery: labels are not case-sensitive
// -- [bug] - IR_next_name needs case-insensitive collision to match zASM
// -- [bug] 'void *ptr = class' is allowed but it's a bug!
//				need need NEEED type checks on assign!
// -- [bug] - number of arguments is not checked, which can fuck with 'this'


int main()
	setup();
	
	init_printf();
	//test_printf();
	
	//printf("Hello [%s] %d!\n", "world", 123);
	printf("Running LazyComp unit tests\n");
	//run_all_tests();
	//printf("&Color = %d\n", &Color);
	//printf("Color.green = %d\n",Color.green);
	//printf("Color.blue = %d\n", Color.blue);
	//class Const_colors Color2;
	//printf("&Color2 = %d, green = %d\n", &Color2, Color2.green);
	Prints("All tests green",90); 	
	screen_clear(); setPrintCursor(0,0);
	printf("hello world!\n");
	





	class Dev_address_bus addr_bus;//(65536, 20000, 20000, 20000);
	class CScreen scr;
	class CSPrinter printer;
	printf("bus %d, CScreen %d, CSPrinter %d\n", &addr_bus, &scr, &printer);
	printf("step 0.");
	addr_bus.constructor(65536, 20000, 20000, 20000);
	printf("1.");
	//printf("addr_bus @ %d, arr @ %d:\n%d %d %d %d\n", 
	//	   &addr_bus, &(addr_bus.addr), 
	//	   addr_bus.addr[0], addr_bus.addr[1], addr_bus.addr[2], addr_bus.addr[3]);
	//int C1 = addr_bus.read(2, 0);
	//int C2 = addr_bus.read(2, 1);
	//printf("C1 %d (%c), C2 %d (%c)\n", C1, C1, C2, C2);

	scr.constructor();
	printf("2.");
	scr.set(addr_bus.addr[2]);
	printf("... scr.memscr = %d\n", scr.mem_scr);
	printf("3.");
	printer.init();
	printf("4.");
	printer.scr = &scr;
	printf("... printer.scr = %d\n", printer.scr);
	printf(".printer.scr.memscr = %d\n", printer.scr.mem_scr);
	printf("... scr.memscr = %d\n", scr.mem_scr);
	printf("5.");
	printer.puts("Hello from CSPrinter!\n");
	printf("z.");
	
	class Derp derp(4, 10);
	printf("&derp = %d, derp.x = %d\n", &derp, derp.x);
	
	infloop();
end
