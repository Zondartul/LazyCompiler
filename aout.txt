GNU gdb (GDB) 7.6.1
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "mingw32".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from C:\Stride\LazyComp\data\a.exe...done.
(gdb) Starting program: C:\Stride\LazyComp\data/a.exe lazy2.txt
[New Thread 2216.0xe04]
sizeof ast_node = '108'
test diff = '4', size = '4'
Lexxed token [int]=[int]
num allocs: 6, mem used: 26910
node "typename": [int] (0/0)
Lexxed token [ ]=[ ]
num allocs: 10, mem used: 27028
Lexxed token [import]=[import]
num allocs: 11, mem used: 27035
Lexxed token [(]=[(]
num allocs: 13, mem used: 27044
Lexxed token [int]=[int]
num allocs: 14, mem used: 27048
node "typename": [int] (0/0)
Lexxed token [ ]=[ ]
num allocs: 17, mem used: 27170
Lexxed token [arg]=[arg]
num allocs: 18, mem used: 27174
Lexxed token [)]=[)]
num allocs: 20, mem used: 27180
node "var_decl": [arg] (0/1)
node "var_decl_list_ne": [(null)] (1/1)
node "var_decl_list": [(null)] (0/1)
unroll [var_decl_list]  unroll done
Lexxed token [ ]=[ ]
num allocs: 27, mem used: 27530
Lexxed token [end]=[end]
num allocs: 28, mem used: 27534
node "stmt_list": [<empty>] (1/0)
FUNC_DEF ID = [import]
node "func_def": [import] (0/3)
node "decl_stmt": [(null)] (1/1)
node "decl_stmt_list_ne": [(null)] (1/1)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 36, mem used: 28004
Lexxed token [int]=[int]
num allocs: 37, mem used: 28008
node "typename": [int] (0/0)
Lexxed token [ ]=[ ]
num allocs: 40, mem used: 28122
Lexxed token [export]=[export]
num allocs: 41, mem used: 28129
Lexxed token [(]=[(]
num allocs: 43, mem used: 28138
Lexxed token [int]=[int]
num allocs: 44, mem used: 28142
node "typename": [int] (0/0)
Lexxed token [ ]=[ ]
num allocs: 47, mem used: 28280
Lexxed token [arg]=[arg]
num allocs: 48, mem used: 28284
Lexxed token [)]=[)]
num allocs: 50, mem used: 28290
node "var_decl": [arg] (0/1)
node "var_decl_list_ne": [(null)] (1/1)
node "var_decl_list": [(null)] (0/1)
unroll [var_decl_list]  unroll done
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 57, mem used: 28628
Lexxed token [	]=[	]
num allocs: 58, mem used: 28630
Lexxed token [return]=[return]
num allocs: 59, mem used: 28637
Lexxed token [ ]=[ ]
num allocs: 60, mem used: 28639
Lexxed token [arg]=[arg]
num allocs: 61, mem used: 28643
node "expr_id": [arg] (0/0)
Lexxed token [;]=[;]
num allocs: 64, mem used: 28757
node "imp_stmt": [(null)] (4/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (1/1)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 71, mem used: 29131
Lexxed token [end]=[end]
num allocs: 72, mem used: 29135
node "stmt_list": [(null)] (0/1)
unroll [stmt_list]  unroll done
FUNC_DEF ID = [export]
node "func_def": [export] (0/3)
node "decl_stmt": [(null)] (1/1)
node "decl_stmt_list_ne": [(null)] (0/2)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 81, mem used: 29601
Lexxed token [int]=[int]
num allocs: 82, mem used: 29605
node "typename": [int] (0/0)
Lexxed token [ ]=[ ]
num allocs: 85, mem used: 29719
Lexxed token [print]=[print]
num allocs: 86, mem used: 29725
Lexxed token [(]=[(]
num allocs: 88, mem used: 29733
Lexxed token [string]=[string]
num allocs: 89, mem used: 29740
node "typename": [string] (0/0)
Lexxed token [ ]=[ ]
num allocs: 92, mem used: 29857
Lexxed token [str]=[str]
num allocs: 93, mem used: 29861
Lexxed token [)]=[)]
num allocs: 95, mem used: 29867
node "var_decl": [str] (0/1)
node "var_decl_list_ne": [(null)] (1/1)
node "var_decl_list": [(null)] (0/1)
unroll [var_decl_list]  unroll done
Lexxed token [ ]=[ ]
num allocs: 102, mem used: 30261
Lexxed token [end]=[end]
num allocs: 103, mem used: 30265
node "stmt_list": [<empty>] (1/0)
FUNC_DEF ID = [print]
node "func_def": [print] (0/3)
node "decl_stmt": [(null)] (1/1)
node "decl_stmt_list_ne": [(null)] (0/2)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 111, mem used: 30727
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 112, mem used: 30729
Lexxed token [int]=[int]
num allocs: 113, mem used: 30733
node "typename": [int] (0/0)
Lexxed token [ ]=[ ]
num allocs: 116, mem used: 30847
Lexxed token [main]=[main]
num allocs: 117, mem used: 30852
Lexxed token [(]=[(]
num allocs: 119, mem used: 30859
Lexxed token [int]=[int]
num allocs: 120, mem used: 30863
node "typename": [int] (0/0)
Lexxed token [ ]=[ ]
num allocs: 123, mem used: 30977
Lexxed token [argc]=[argc]
num allocs: 124, mem used: 30982
Lexxed token [,]=[,]
num allocs: 126, mem used: 30989
node "var_decl": [argc] (0/1)
node "var_decl_list_ne": [(null)] (1/1)
Lexxed token [ ]=[ ]
num allocs: 131, mem used: 31215
Lexxed token [int]=[int]
num allocs: 132, mem used: 31219
node "typename": [int] (0/0)
Lexxed token [ ]=[ ]
num allocs: 135, mem used: 31333
Lexxed token [argv]=[argv]
num allocs: 136, mem used: 31338
Lexxed token [)]=[)]
num allocs: 138, mem used: 31345
node "var_decl": [argv] (0/1)
node "var_decl_list_ne": [(null)] (0/2)
node "var_decl_list": [(null)] (0/1)
unroll [var_decl_list]  unroll done
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 145, mem used: 31699
Lexxed token [	]=[	]
num allocs: 146, mem used: 31701
Lexxed token [char]=[char]
num allocs: 147, mem used: 31706
node "typename": [char] (0/0)
Lexxed token [ ]=[ ]
num allocs: 150, mem used: 31905
Lexxed token [C]=[C]
num allocs: 151, mem used: 31907
Lexxed token [;]=[;]
num allocs: 153, mem used: 31911
node "var_decl": [C] (0/1)
node "decl_stmt": [(null)] (2/1)
node "stmt": [(null)] (1/1)
node "stmt_list_ne": [(null)] (1/1)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 162, mem used: 32361
Lexxed token [	]=[	]
num allocs: 163, mem used: 32363
Lexxed token [int]=[int]
num allocs: 164, mem used: 32367
node "typename": [int] (0/0)
Lexxed token [ ]=[ ]
num allocs: 167, mem used: 32481
Lexxed token [A]=[A]
num allocs: 168, mem used: 32483
Lexxed token [;]=[;]
num allocs: 170, mem used: 32487
node "var_decl": [A] (0/1)
node "decl_stmt": [(null)] (2/1)
node "stmt": [(null)] (1/1)
node "stmt_list_ne": [(null)] (0/2)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 179, mem used: 32945
Lexxed token [	]=[	]
num allocs: 180, mem used: 32947
Lexxed token [if]=[if]
num allocs: 181, mem used: 32950
Lexxed token [(]=[(]
num allocs: 182, mem used: 32952
Lexxed token [argc]=[argc]
num allocs: 183, mem used: 32957
node "expr_id": [argc] (0/0)
Lexxed token [ ]=[ ]
num allocs: 186, mem used: 33072
Lexxed token [=]=[=]
num allocs: 187, mem used: 33074
Lexxed token [ ]=[ ]
num allocs: 188, mem used: 33076
Lexxed token [0]=[0]
num allocs: 189, mem used: 33078
node "expr_const": [0] (0/0)
Lexxed token [)]=[)]
num allocs: 192, mem used: 33190
node "expr_=": [(null)] (0/2)
Lexxed token [ ]=[ ]
num allocs: 195, mem used: 33312
Lexxed token [then]=[then]
num allocs: 196, mem used: 33317
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 197, mem used: 33319
Lexxed token [	]=[	]
num allocs: 198, mem used: 33321
Lexxed token [	]=[	]
num allocs: 199, mem used: 33323
Lexxed token [print]=[print]
num allocs: 200, mem used: 33329
node "expr_id": [print] (0/0)
Lexxed token [(]=[(]
num allocs: 203, mem used: 33445
Lexxed token ["usage: a.exe arg1 arg2"]=["usage: a.exe arg1 arg2"]
num allocs: 204, mem used: 33470
node "expr_const": ["usage: a.exe arg1 arg2"] (5/0)
Lexxed token [)]=[)]
num allocs: 207, mem used: 33605
node "expr_list_ne": [(null)] (1/1)
node "expr_list": [(null)] (0/1)
unroll [expr_list]  unroll done
node "expr_call": [(null)] (0/2)
Lexxed token [;]=[;]
num allocs: 214, mem used: 33951
node "imp_stmt": [(null)] (2/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (1/1)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 221, mem used: 34289
Lexxed token [	]=[	]
num allocs: 222, mem used: 34291
Lexxed token [	]=[	]
num allocs: 223, mem used: 34293
Lexxed token [A]=[A]
num allocs: 224, mem used: 34295
node "expr_id": [A] (0/0)
Lexxed token [ ]=[ ]
num allocs: 227, mem used: 34531
Lexxed token [=]=[=]
num allocs: 228, mem used: 34533
Lexxed token [ ]=[ ]
num allocs: 229, mem used: 34535
Lexxed token [5]=[5]
num allocs: 230, mem used: 34537
node "expr_const": [5] (0/0)
Lexxed token [;]=[;]
num allocs: 233, mem used: 34649
node "expr_=": [(null)] (0/2)
node "imp_stmt": [(null)] (2/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 242, mem used: 35115
Lexxed token [	]=[	]
num allocs: 243, mem used: 35117
Lexxed token [	]=[	]
num allocs: 244, mem used: 35119
Lexxed token [return]=[return]
num allocs: 245, mem used: 35126
Lexxed token [ ]=[ ]
num allocs: 246, mem used: 35128
Lexxed token [1]=[1]
num allocs: 247, mem used: 35130
node "expr_const": [1] (0/0)
Lexxed token [;]=[;]
num allocs: 250, mem used: 35242
node "imp_stmt": [(null)] (4/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 257, mem used: 35588
Lexxed token [	]=[	]
num allocs: 258, mem used: 35590
Lexxed token [else]=[else]
num allocs: 259, mem used: 35595
node "stmt_list": [(null)] (0/1)
unroll [stmt_list]  unroll done
node "if_then": [(null)] (0/2)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 264, mem used: 35837
Lexxed token [	]=[	]
num allocs: 265, mem used: 35839
Lexxed token [	]=[	]
num allocs: 266, mem used: 35841
Lexxed token [float]=[float]
num allocs: 267, mem used: 35847
node "typename": [float] (0/0)
Lexxed token [ ]=[ ]
num allocs: 270, mem used: 35963
Lexxed token [A]=[A]
num allocs: 271, mem used: 35965
Lexxed token [ ]=[ ]
num allocs: 273, mem used: 35969
Lexxed token [=]=[=]
num allocs: 274, mem used: 35971
Lexxed token [ ]=[ ]
num allocs: 275, mem used: 35973
Lexxed token [import]=[import]
num allocs: 276, mem used: 35980
node "expr_id": [import] (0/0)
Lexxed token [(]=[(]
num allocs: 279, mem used: 36097
Lexxed token [argc]=[argc]
num allocs: 280, mem used: 36102
node "expr_id": [argc] (0/0)
Lexxed token [)]=[)]
num allocs: 283, mem used: 36217
node "expr_list_ne": [(null)] (1/1)
node "expr_list": [(null)] (0/1)
unroll [expr_list]  unroll done
node "expr_call": [(null)] (0/2)
Lexxed token [;]=[;]
num allocs: 290, mem used: 36563
node "var_decl_assign": [A] (1/2)
node "decl_stmt": [(null)] (2/1)
node "stmt": [(null)] (1/1)
node "stmt_list_ne": [(null)] (1/1)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 299, mem used: 37021
Lexxed token [	]=[	]
num allocs: 300, mem used: 37023
Lexxed token [	]=[	]
num allocs: 301, mem used: 37025
Lexxed token [A]=[A]
num allocs: 302, mem used: 37027
node "expr_id": [A] (0/0)
Lexxed token [ ]=[ ]
num allocs: 305, mem used: 37139
Lexxed token [=]=[=]
num allocs: 306, mem used: 37141
Lexxed token [ ]=[ ]
num allocs: 307, mem used: 37143
Lexxed token [A]=[A]
num allocs: 308, mem used: 37145
node "expr_id": [A] (0/0)
Lexxed token [*]=[*]
num allocs: 311, mem used: 37257
Lexxed token [argv]=[argv]
num allocs: 312, mem used: 37262
node "expr_id": [argv] (0/0)
Lexxed token [;]=[;]
num allocs: 315, mem used: 37377
node "expr_*": [(null)] (0/2)
node "expr_=": [(null)] (0/2)
node "imp_stmt": [(null)] (2/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 326, mem used: 37963
Lexxed token [	]=[	]
num allocs: 327, mem used: 37965
Lexxed token [	]=[	]
num allocs: 328, mem used: 37967
Lexxed token [export]=[export]
num allocs: 329, mem used: 37974
node "expr_id": [export] (0/0)
Lexxed token [(]=[(]
num allocs: 332, mem used: 38091
Lexxed token [A]=[A]
num allocs: 333, mem used: 38093
node "expr_id": [A] (0/0)
Lexxed token [)]=[)]
num allocs: 336, mem used: 38393
node "expr_list_ne": [(null)] (1/1)
node "expr_list": [(null)] (0/1)
unroll [expr_list]  unroll done
node "expr_call": [(null)] (0/2)
Lexxed token [;]=[;]
num allocs: 343, mem used: 38739
node "imp_stmt": [(null)] (2/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 350, mem used: 39085
Lexxed token [	]=[	]
num allocs: 351, mem used: 39087
Lexxed token [	]=[	]
num allocs: 352, mem used: 39089
Lexxed token [while]=[while]
num allocs: 353, mem used: 39095
Lexxed token [(]=[(]
num allocs: 354, mem used: 39097
Lexxed token [A]=[A]
num allocs: 355, mem used: 39099
node "expr_id": [A] (0/0)
Lexxed token [)]=[)]
num allocs: 358, mem used: 39211
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 359, mem used: 39213
Lexxed token [	]=[	]
num allocs: 360, mem used: 39215
Lexxed token [	]=[	]
num allocs: 361, mem used: 39217
Lexxed token [	]=[	]
num allocs: 362, mem used: 39219
Lexxed token [print]=[print]
num allocs: 363, mem used: 39225
node "expr_id": [print] (0/0)
Lexxed token [(]=[(]
num allocs: 366, mem used: 39341
Lexxed token [A]=[A]
num allocs: 367, mem used: 39343
node "expr_id": [A] (0/0)
Lexxed token [,]=[,]
num allocs: 370, mem used: 39455
node "expr_list_ne": [(null)] (1/1)
Lexxed token [ ]=[ ]
num allocs: 373, mem used: 39569
Lexxed token [argc]=[argc]
num allocs: 374, mem used: 39574
node "expr_id": [argc] (0/0)
Lexxed token [)]=[)]
num allocs: 377, mem used: 39689
node "expr_list_ne": [(null)] (0/2)
node "expr_list": [(null)] (0/1)
unroll [expr_list]  unroll done
node "expr_call": [(null)] (0/2)
Lexxed token [;]=[;]
num allocs: 384, mem used: 40051
node "imp_stmt": [(null)] (2/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (1/1)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 391, mem used: 40389
Lexxed token [	]=[	]
num allocs: 392, mem used: 40391
Lexxed token [	]=[	]
num allocs: 393, mem used: 40393
Lexxed token [	]=[	]
num allocs: 394, mem used: 40395
Lexxed token [A]=[A]
num allocs: 395, mem used: 40397
node "expr_id": [A] (0/0)
Lexxed token [ ]=[ ]
num allocs: 398, mem used: 40509
Lexxed token [=]=[=]
num allocs: 399, mem used: 40511
Lexxed token [ ]=[ ]
num allocs: 400, mem used: 40513
Lexxed token [A]=[A]
num allocs: 401, mem used: 40515
node "expr_id": [A] (0/0)
Lexxed token [/]=[/]
num allocs: 404, mem used: 40627
Lexxed token [1]=[1]
num allocs: 405, mem used: 40629
node "expr_const": [1] (0/0)
Lexxed token [;]=[;]
num allocs: 408, mem used: 40741
node "expr_/": [(null)] (0/2)
node "expr_=": [(null)] (0/2)
node "imp_stmt": [(null)] (2/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 419, mem used: 41327
Lexxed token [	]=[	]
num allocs: 420, mem used: 41329
Lexxed token [	]=[	]
num allocs: 421, mem used: 41331
Lexxed token [	]=[	]
num allocs: 422, mem used: 41333
Lexxed token [if]=[if]
num allocs: 423, mem used: 41336
Lexxed token [(]=[(]
num allocs: 424, mem used: 41338
Lexxed token [A]=[A]
num allocs: 425, mem used: 41340
node "expr_id": [A] (0/0)
Lexxed token [ ]=[ ]
num allocs: 428, mem used: 41452
Lexxed token [=]=[=]
num allocs: 429, mem used: 41454
Lexxed token [ ]=[ ]
num allocs: 430, mem used: 41456
Lexxed token [1]=[1]
num allocs: 431, mem used: 41458
node "expr_const": [1] (0/0)
Lexxed token [)]=[)]
num allocs: 434, mem used: 41570
node "expr_=": [(null)] (0/2)
Lexxed token [ ]=[ ]
num allocs: 437, mem used: 41692
Lexxed token [then]=[then]
num allocs: 438, mem used: 41697
Lexxed token [ ]=[ ]
num allocs: 439, mem used: 41699
Lexxed token [return]=[return]
num allocs: 440, mem used: 41706
Lexxed token [ ]=[ ]
num allocs: 441, mem used: 41708
Lexxed token [1]=[1]
num allocs: 442, mem used: 41710
node "expr_const": [1] (0/0)
Lexxed token [;]=[;]
num allocs: 445, mem used: 41822
node "imp_stmt": [(null)] (4/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (1/1)
Lexxed token [ ]=[ ]
num allocs: 452, mem used: 42160
Lexxed token [end]=[end]
num allocs: 453, mem used: 42164
node "stmt_list": [(null)] (0/1)
unroll [stmt_list]  unroll done
node "if_then": [(null)] (0/2)
node "if_block": [(null)] (0/1)
node "imp_stmt": [(null)] (0/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 466, mem used: 42854
Lexxed token [	]=[	]
num allocs: 467, mem used: 42856
Lexxed token [	]=[	]
num allocs: 468, mem used: 42858
Lexxed token [end]=[end]
num allocs: 469, mem used: 42862
node "stmt_list": [(null)] (0/1)
unroll [stmt_list]  unroll done
node "while_loop": [(null)] (0/2)
node "imp_stmt": [(null)] (1/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 480, mem used: 43448
Lexxed token [	]=[	]
num allocs: 481, mem used: 43450
Lexxed token [	]=[	]
num allocs: 482, mem used: 43452
Lexxed token [return]=[return]
num allocs: 483, mem used: 43459
Lexxed token [ ]=[ ]
num allocs: 484, mem used: 43461
Lexxed token [0]=[0]
num allocs: 485, mem used: 43463
node "expr_const": [0] (0/0)
Lexxed token [;]=[;]
num allocs: 488, mem used: 43575
node "imp_stmt": [(null)] (4/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 495, mem used: 44201
Lexxed token [	]=[	]
num allocs: 496, mem used: 44203
Lexxed token [end]=[end]
num allocs: 497, mem used: 44207
node "stmt_list": [(null)] (0/1)
unroll [stmt_list]  unroll done
node "if_block": [(null)] (1/2)
node "imp_stmt": [(null)] (0/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 508, mem used: 44829
Lexxed token [	]=[	]
num allocs: 509, mem used: 44831
Lexxed token [string]=[string]
num allocs: 510, mem used: 44838
node "typename": [string] (0/0)
Lexxed token [ ]=[ ]
num allocs: 513, mem used: 44955
Lexxed token [boop]=[boop]
num allocs: 514, mem used: 44960
Lexxed token [;]=[;]
num allocs: 516, mem used: 44967
node "var_decl": [boop] (0/1)
node "decl_stmt": [(null)] (2/1)
node "stmt": [(null)] (1/1)
node "stmt_list_ne": [(null)] (0/2)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 525, mem used: 45425
Lexxed token [end]=[end]
num allocs: 526, mem used: 45429
node "stmt_list": [(null)] (0/1)
unroll [stmt_list]  unroll done
FUNC_DEF ID = [main]
node "func_def": [main] (0/3)
node "decl_stmt": [(null)] (1/1)
node "decl_stmt_list_ne": [(null)] (0/2)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 535, mem used: 45927
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 536, mem used: 45929
Lexxed token [class]=[class]
num allocs: 537, mem used: 45935
Lexxed token [ ]=[ ]
num allocs: 538, mem used: 45937
Lexxed token [horse]=[horse]
num allocs: 539, mem used: 45943
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 541, mem used: 45951
Lexxed token [	]=[	]
num allocs: 542, mem used: 45953
Lexxed token [float]=[float]
num allocs: 543, mem used: 45959
node "typename": [float] (0/0)
Lexxed token [ ]=[ ]
num allocs: 546, mem used: 46075
Lexxed token [fluff]=[fluff]
num allocs: 547, mem used: 46081
Lexxed token [ ]=[ ]
num allocs: 549, mem used: 46089
Lexxed token [=]=[=]
num allocs: 550, mem used: 46091
Lexxed token [ ]=[ ]
num allocs: 551, mem used: 46093
Lexxed token [5]=[5]
num allocs: 552, mem used: 46095
node "expr_const": [5] (0/0)
Lexxed token [;]=[;]
num allocs: 555, mem used: 46207
node "var_decl_assign": [fluff] (1/2)
node "decl_stmt": [(null)] (2/1)
node "decl_stmt_list_ne": [(null)] (1/1)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 562, mem used: 46553
Lexxed token [	]=[	]
num allocs: 563, mem used: 46555
Lexxed token [int]=[int]
num allocs: 564, mem used: 46559
node "typename": [int] (0/0)
Lexxed token [ ]=[ ]
num allocs: 567, mem used: 46673
Lexxed token [boop]=[boop]
num allocs: 568, mem used: 46678
Lexxed token [(]=[(]
num allocs: 570, mem used: 46685
Lexxed token [)]=[)]
num allocs: 571, mem used: 46687
node "var_decl_list": [<empty>] (1/0)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 573, mem used: 46797
Lexxed token [	]=[	]
num allocs: 574, mem used: 46799
Lexxed token [	]=[	]
num allocs: 575, mem used: 46801
Lexxed token [fluff]=[fluff]
num allocs: 576, mem used: 46807
node "expr_id": [fluff] (0/0)
Lexxed token [ ]=[ ]
num allocs: 579, mem used: 46923
Lexxed token [=]=[=]
num allocs: 580, mem used: 46925
Lexxed token [ ]=[ ]
num allocs: 581, mem used: 46927
Lexxed token [fluff]=[fluff]
num allocs: 582, mem used: 46933
node "expr_id": [fluff] (0/0)
Lexxed token [+]=[+]
num allocs: 585, mem used: 47049
Lexxed token [1]=[1]
num allocs: 586, mem used: 47051
node "expr_const": [1] (0/0)
Lexxed token [;]=[;]
num allocs: 589, mem used: 47163
node "expr_+": [(null)] (0/2)
node "expr_=": [(null)] (0/2)
node "imp_stmt": [(null)] (2/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (1/1)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 600, mem used: 47741
Lexxed token [	]=[	]
num allocs: 601, mem used: 47743
Lexxed token [end]=[end]
num allocs: 602, mem used: 47747
node "stmt_list": [(null)] (0/1)
unroll [stmt_list]  unroll done
FUNC_DEF ID = [boop]
node "func_def": [boop] (0/3)
node "decl_stmt": [(null)] (1/1)
node "decl_stmt_list_ne": [(null)] (0/2)
lex: newline i=0
Lexxed token [
]=[
]
num allocs: 611, mem used: 48213
Lexxed token [end]=[end]
num allocs: 612, mem used: 48217
node "decl_stmt_list": [(null)] (0/1)
unroll [decl_stmt_list]  unroll done
FUNC_DEF ID = [horse]
node "class_def": [horse] (0/1)
node "decl_stmt": [(null)] (0/1)
node "decl_stmt_list_ne": [(null)] (0/2)
node "decl_stmt_list": [(null)] (0/1)
unroll [decl_stmt_list]  unroll done
node "program": [(null)] (0/1)

PARSING DONE
printing ast 007A3930, 773029A0, 0, [program]
printing ast 007A37F8, 773029A0, 0, [decl_stmt_list]
printing ast 0063A420, 773029A0, 0, [decl_stmt]
printing ast 0063A330, 773029A0, 0, [func_def]
printing ast 00631180, 773029A0, 0, [typename]
printing ast 0063A200, 773029A0, 1, [var_decl_list]
printing ast 0063A0C0, 773029A0, 0, [var_decl]
printing ast 006312E8, 773029A0, 0, [typename]
printing ast 0063A2A8, 773029A0, 2, [stmt_list]
printing ast 0063AF48, 773029A0, 1, [decl_stmt]
printing ast 0063AE98, 773029A0, 0, [func_def]
printing ast 0063A5B0, 773029A0, 0, [typename]
printing ast 0063A968, 773029A0, 1, [var_decl_list]
printing ast 0063A818, 773029A0, 0, [var_decl]
printing ast 0063A6F8, 773029A0, 0, [typename]
printing ast 0063ADF0, 773029A0, 2, [stmt_list]
printing ast 0063AC20, 773029A0, 0, [stmt]
printing ast 0063AB78, 773029A0, 0, [imp_stmt]
printing ast 0063AAD0, 773029A0, 0, [expr_id]
printing ast 0063B718, 773029A0, 2, [decl_stmt]
printing ast 0063B668, 773029A0, 0, [func_def]
printing ast 0063B100, 773029A0, 0, [typename]
printing ast 0063B558, 773029A0, 1, [var_decl_list]
printing ast 0063B350, 773029A0, 0, [var_decl]
printing ast 0063B248, 773029A0, 0, [typename]
printing ast 0063B5E0, 773029A0, 2, [stmt_list]
printing ast 007A2270, 773029A0, 3, [decl_stmt]
printing ast 007A21E8, 773029A0, 0, [func_def]
printing ast 0063B8D0, 773029A0, 0, [typename]
printing ast 0063BF30, 773029A0, 1, [var_decl_list]
printing ast 0063BB20, 773029A0, 0, [var_decl]
printing ast 0063BA18, 773029A0, 0, [typename]
printing ast 0063BDD8, 773029A0, 1, [var_decl]
printing ast 0063BCD0, 773029A0, 0, [typename]
printing ast 007A20E0, 773029A0, 2, [stmt_list]
printing ast 0063C320, 773029A0, 0, [stmt]
printing ast 0063C278, 773029A0, 0, [decl_stmt]
printing ast 0063C1F0, 773029A0, 0, [var_decl]
printing ast 0063C060, 773029A0, 0, [typename]
printing ast 0063C748, 773029A0, 1, [stmt]
printing ast 0063C6A0, 773029A0, 0, [decl_stmt]
printing ast 0063C5F8, 773029A0, 0, [var_decl]
printing ast 0063C4F0, 773029A0, 0, [typename]
printing ast 007A1B60, 773029A0, 2, [stmt]
printing ast 007A1AD8, 773029A0, 0, [imp_stmt]
printing ast 0063F060, 773029A0, 0, [if_block]
printing ast 0063DCD0, 773029A0, 0, [if_then]
printing ast 0063CB30, 773029A0, 0, [expr_=]
printing ast 0063C960, 773029A0, 0, [expr_id]
printing ast 0063CA88, 773029A0, 1, [expr_const]
printing ast 0063DC20, 773029A0, 1, [stmt_list]
printing ast 0063D148, 773029A0, 0, [stmt]
printing ast 0063D0A0, 773029A0, 0, [imp_stmt]
printing ast 0063CFD0, 773029A0, 0, [expr_call]
printing ast 0063CCC0, 773029A0, 0, [expr_id]
printing ast 0063CF28, 773029A0, 1, [expr_list]
printing ast 0063CDD8, 773029A0, 0, [expr_const]
printing ast 0063D6E0, 773029A0, 1, [stmt]
printing ast 0063D658, 773029A0, 0, [imp_stmt]
printing ast 0063D5D0, 773029A0, 0, [expr_=]
printing ast 0063D338, 773029A0, 0, [expr_id]
printing ast 0063D548, 773029A0, 1, [expr_const]
printing ast 0063DA68, 773029A0, 2, [stmt]
printing ast 0063D9C0, 773029A0, 0, [imp_stmt]
printing ast 0063D918, 773029A0, 0, [expr_const]
printing ast 0063EF28, 773029A0, 1, [stmt_list]
printing ast 0063E4B0, 773029A0, 0, [stmt]
printing ast 0063E408, 773029A0, 0, [decl_stmt]
printing ast 0063E358, 773029A0, 0, [var_decl_assign]
printing ast 0063DE20, 773029A0, 0, [typename]
printing ast 0063E288, 773029A0, 1, [expr_call]
printing ast 0063DFA8, 773029A0, 0, [expr_id]
printing ast 0063E1E0, 773029A0, 1, [expr_list]
printing ast 0063E090, 773029A0, 0, [expr_id]
printing ast 0063EB60, 773029A0, 1, [stmt]
printing ast 0063EAB8, 773029A0, 0, [imp_stmt]
printing ast 0063EA08, 773029A0, 0, [expr_=]
printing ast 0063E6A0, 773029A0, 0, [expr_id]
printing ast 0063E958, 773029A0, 1, [expr_*]
printing ast 0063E7C8, 773029A0, 0, [expr_id]
printing ast 0063E8B0, 773029A0, 1, [expr_id]
printing ast 0063F280, 773029A0, 2, [stmt]
printing ast 0063F1D8, 773029A0, 0, [imp_stmt]
printing ast 0063F108, 773029A0, 0, [expr_call]
printing ast 0063ED58, 773029A0, 0, [expr_id]
printing ast 0063D488, 773029A0, 1, [expr_list]
printing ast 0063EE40, 773029A0, 0, [expr_id]
printing ast 007A12A0, 773029A0, 3, [stmt]
printing ast 007A11F8, 773029A0, 0, [imp_stmt]
printing ast 007A1148, 773029A0, 0, [while_loop]
printing ast 0063F4B8, 773029A0, 0, [expr_id]
printing ast 007A1098, 773029A0, 1, [stmt_list]
printing ast 0063FC38, 773029A0, 0, [stmt]
printing ast 0063FB90, 773029A0, 0, [imp_stmt]
printing ast 0063FAC0, 773029A0, 0, [expr_call]
printing ast 0063F620, 773029A0, 0, [expr_id]
printing ast 0063FA10, 773029A0, 1, [expr_list]
printing ast 0063F708, 773029A0, 0, [expr_id]
printing ast 0063F8B8, 773029A0, 1, [expr_id]
printing ast 007A0380, 773029A0, 1, [stmt]
printing ast 007A02D8, 773029A0, 0, [imp_stmt]
printing ast 007A0228, 773029A0, 0, [expr_=]
printing ast 0063FE48, 773029A0, 0, [expr_id]
printing ast 007A0178, 773029A0, 1, [expr_/]
printing ast 007A0048, 773029A0, 0, [expr_id]
printing ast 007A00D0, 773029A0, 1, [expr_const]
printing ast 007A0EC0, 773029A0, 2, [stmt]
printing ast 007A0E18, 773029A0, 0, [imp_stmt]
printing ast 007A0D70, 773029A0, 0, [if_block]
printing ast 007A0CC0, 773029A0, 0, [if_then]
printing ast 007A07A8, 773029A0, 0, [expr_=]
printing ast 007A05D8, 773029A0, 0, [expr_id]
printing ast 007A0700, 773029A0, 1, [expr_const]
printing ast 007A0C18, 773029A0, 1, [stmt_list]
printing ast 007A0A88, 773029A0, 0, [stmt]
printing ast 007A09E0, 773029A0, 0, [imp_stmt]
printing ast 007A0938, 773029A0, 0, [expr_const]
printing ast 007A1628, 773029A0, 4, [stmt]
printing ast 007A1580, 773029A0, 0, [imp_stmt]
printing ast 007A14D8, 773029A0, 0, [expr_const]
printing ast 007A1F48, 773029A0, 3, [stmt]
printing ast 007A1EA0, 773029A0, 0, [decl_stmt]
printing ast 007A1DF8, 773029A0, 0, [var_decl]
printing ast 007A1CF0, 773029A0, 0, [typename]
printing ast 007A36A0, 773029A0, 4, [decl_stmt]
printing ast 007A35F8, 773029A0, 0, [class_def]
printing ast 007A3548, 773029A0, 0, [decl_stmt_list]
printing ast 007A27C8, 773029A0, 0, [decl_stmt]
printing ast 007A2718, 773029A0, 0, [var_decl_assign]
printing ast 007A24E8, 773029A0, 0, [typename]
printing ast 007A2670, 773029A0, 1, [expr_const]
printing ast 007A33B0, 773029A0, 1, [decl_stmt]
printing ast 007A3300, 773029A0, 0, [func_def]
printing ast 007A2998, 773029A0, 0, [typename]
printing ast 007A2AC0, 773029A0, 1, [var_decl_list]
printing ast 007A3258, 773029A0, 2, [stmt_list]
printing ast 007A30A8, 773029A0, 0, [stmt]
printing ast 007A3000, 773029A0, 0, [imp_stmt]
printing ast 007A2F50, 773029A0, 0, [expr_=]
printing ast 007A2BE8, 773029A0, 0, [expr_id]
printing ast 007A2EA0, 773029A0, 1, [expr_+]
printing ast 007A2D10, 773029A0, 0, [expr_id]
printing ast 007A2DF8, 773029A0, 1, [expr_const]

PRINTING DONE
semantic got program, prod 0, @ 0-453, imperative pass
-----------------
int import(int arg) end
int export(int arg)
	return arg;
end
int print(string str) end

int main(int argc, int argv)
	char C;
	int A;
	if(argc = 0) then
		print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
	else
		float A = import(argc);
		A = A*argv;
		export(A);
		while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
		return 0;
	end
	string boop;
end

class horse
	float fluff = 5;
	int boop()
		fluff = fluff+1;
	end
end
-----------------
IR_next_name: returning [ST$1]
 semantic got decl_stmt_list, prod 0, @ 0-453, declarative pass
-----------------
int import(int arg) end
int export(int arg)
	return arg;
end
int print(string str) end

int main(int argc, int argv)
	char C;
	int A;
	if(argc = 0) then
		print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
	else
		float A = import(argc);
		A = A*argv;
		export(A);
		while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
		return 0;
	end
	string boop;
end

class horse
	float fluff = 5;
	int boop()
		fluff = fluff+1;
	end
end
-----------------
  semantic got decl_stmt, prod 1, @ 0-23, declarative pass
-----------------
int import(int arg) end
-----------------
   semantic got func_def, "import", prod 0, @ 0-23, declarative pass
-----------------
int import(int arg) end
-----------------
IR_next_name: returning [import$1]
IR_next_name: returning [ST$2]
    semantic got var_decl, "arg", prod 0, @ 11-18, declarative pass
-----------------
int arg
-----------------
IR_next_name: returning [arg$1]
  semantic got decl_stmt, prod 1, @ 24-60, declarative pass
-----------------
int export(int arg)
	return arg;
end
-----------------
   semantic got func_def, "export", prod 0, @ 24-60, declarative pass
-----------------
int export(int arg)
	return arg;
end
-----------------
IR_next_name: returning [export$1]
IR_next_name: returning [ST$3]
    semantic got var_decl, "arg", prod 0, @ 35-42, declarative pass
-----------------
int arg
-----------------
IR_next_name: returning [arg$2]
  semantic got decl_stmt, prod 1, @ 61-86, declarative pass
-----------------
int print(string str) end
-----------------
   semantic got func_def, "print", prod 0, @ 61-86, declarative pass
-----------------
int print(string str) end
-----------------
IR_next_name: returning [print$1]
IR_next_name: returning [ST$4]
    semantic got var_decl, "str", prod 0, @ 71-81, declarative pass
-----------------
string str
-----------------
IR_next_name: returning [str$1]
  semantic got decl_stmt, prod 1, @ 88-382, declarative pass
-----------------
int main(int argc, int argv)
	char C;
	int A;
	if(argc = 0) then
		print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
	else
		float A = import(argc);
		A = A*argv;
		export(A);
		while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
		return 0;
	end
	string boop;
end
-----------------
   semantic got func_def, "main", prod 0, @ 88-382, declarative pass
-----------------
int main(int argc, int argv)
	char C;
	int A;
	if(argc = 0) then
		print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
	else
		float A = import(argc);
		A = A*argv;
		export(A);
		while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
		return 0;
	end
	string boop;
end
-----------------
IR_next_name: returning [main$1]
IR_next_name: returning [ST$5]
    semantic got var_decl, "argc", prod 0, @ 97-105, declarative pass
-----------------
int argc
-----------------
IR_next_name: returning [argc$1]
    semantic got var_decl, "argv", prod 0, @ 107-115, declarative pass
-----------------
int argv
-----------------
IR_next_name: returning [argv$1]
  semantic got decl_stmt, prod 0, @ 384-453, declarative pass
-----------------
class horse
	float fluff = 5;
	int boop()
		fluff = fluff+1;
	end
end
-----------------
   semantic got class_def, "horse", prod 0, @ 384-453, declarative pass
-----------------
class horse
	float fluff = 5;
	int boop()
		fluff = fluff+1;
	end
end
-----------------
IR_next_name: returning [horse$1]
IR_next_name: returning [ST$6]
    semantic got decl_stmt_list, prod 0, @ 397-449, declarative pass
-----------------
float fluff = 5;
	int boop()
		fluff = fluff+1;
	end
-----------------
     semantic got decl_stmt, prod 2, @ 397-413, declarative pass
-----------------
float fluff = 5;
-----------------
      semantic got var_decl_assign, "fluff", prod 1, @ 397-412, declarative pass
-----------------
float fluff = 5
-----------------
IR_next_name: returning [fluff$1]
     semantic got decl_stmt, prod 1, @ 415-449, declarative pass
-----------------
int boop()
		fluff = fluff+1;
	end
-----------------
      semantic got func_def, "boop", prod 0, @ 415-449, declarative pass
-----------------
int boop()
		fluff = fluff+1;
	end
-----------------
IR_next_name: returning [boop$1]
IR_next_name: returning [ST$7]
 semantic got decl_stmt_list, prod 0, @ 0-453, imperative pass
-----------------
int import(int arg) end
int export(int arg)
	return arg;
end
int print(string str) end

int main(int argc, int argv)
	char C;
	int A;
	if(argc = 0) then
		print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
	else
		float A = import(argc);
		A = A*argv;
		export(A);
		while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
		return 0;
	end
	string boop;
end

class horse
	float fluff = 5;
	int boop()
		fluff = fluff+1;
	end
end
-----------------
  semantic got decl_stmt, prod 1, @ 0-23, imperative pass
-----------------
int import(int arg) end
-----------------
   semantic got func_def, "import", prod 0, @ 0-23, imperative pass
-----------------
int import(int arg) end
-----------------
found symbol 'import'->'ST$1'
IR_next_name: returning [CS$1]
    semantic got stmt_list, "<empty>", prod 1, @ 19-19, declarative pass
-----------------

-----------------
    semantic got stmt_list, "<empty>", prod 1, @ 19-19, imperative pass
-----------------

-----------------
  semantic got decl_stmt, prod 1, @ 24-60, imperative pass
-----------------
int export(int arg)
	return arg;
end
-----------------
   semantic got func_def, "export", prod 0, @ 24-60, imperative pass
-----------------
int export(int arg)
	return arg;
end
-----------------
found symbol 'export'->'ST$1'
IR_next_name: returning [CS$2]
    semantic got stmt_list, prod 0, @ 45-56, declarative pass
-----------------
return arg;
-----------------
     semantic got stmt, prod 0, @ 45-56, declarative pass
-----------------
return arg;
-----------------
      semantic got imp_stmt, prod 4, @ 45-56, declarative pass
-----------------
return arg;
-----------------
    semantic got stmt_list, prod 0, @ 45-56, imperative pass
-----------------
return arg;
-----------------
     semantic got stmt, prod 0, @ 45-56, imperative pass
-----------------
return arg;
-----------------
      semantic got imp_stmt, prod 4, @ 45-56, imperative pass
-----------------
return arg;
-----------------
       semantic got expr_id, "arg", prod 0, @ 52-55, imperative pass
-----------------
arg
-----------------
found symbol 'arg'->'ST$3'
  semantic got decl_stmt, prod 1, @ 61-86, imperative pass
-----------------
int print(string str) end
-----------------
   semantic got func_def, "print", prod 0, @ 61-86, imperative pass
-----------------
int print(string str) end
-----------------
found symbol 'print'->'ST$1'
IR_next_name: returning [CS$3]
    semantic got stmt_list, "<empty>", prod 1, @ 21-21, declarative pass
-----------------

-----------------
    semantic got stmt_list, "<empty>", prod 1, @ 21-21, imperative pass
-----------------

-----------------
  semantic got decl_stmt, prod 1, @ 88-382, imperative pass
-----------------
int main(int argc, int argv)
	char C;
	int A;
	if(argc = 0) then
		print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
	else
		float A = import(argc);
		A = A*argv;
		export(A);
		while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
		return 0;
	end
	string boop;
end
-----------------
   semantic got func_def, "main", prod 0, @ 88-382, imperative pass
-----------------
int main(int argc, int argv)
	char C;
	int A;
	if(argc = 0) then
		print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
	else
		float A = import(argc);
		A = A*argv;
		export(A);
		while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
		return 0;
	end
	string boop;
end
-----------------
found symbol 'main'->'ST$1'
IR_next_name: returning [CS$4]
    semantic got stmt_list, prod 0, @ 118-378, declarative pass
-----------------
char C;
	int A;
	if(argc = 0) then
		print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
	else
		float A = import(argc);
		A = A*argv;
		export(A);
		while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
		return 0;
	end
	string boop;
-----------------
     semantic got stmt, prod 1, @ 118-125, declarative pass
-----------------
char C;
-----------------
      semantic got decl_stmt, prod 2, @ 118-125, declarative pass
-----------------
char C;
-----------------
       semantic got var_decl, "C", prod 0, @ 118-124, declarative pass
-----------------
char C
-----------------
IR_next_name: returning [C$1]
     semantic got stmt, prod 1, @ 127-133, declarative pass
-----------------
int A;
-----------------
      semantic got decl_stmt, prod 2, @ 127-133, declarative pass
-----------------
int A;
-----------------
       semantic got var_decl, "A", prod 0, @ 127-132, declarative pass
-----------------
int A
-----------------
IR_next_name: returning [A$1]
     semantic got stmt, prod 0, @ 135-364, declarative pass
-----------------
if(argc = 0) then
		print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
	else
		float A = import(argc);
		A = A*argv;
		export(A);
		while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
		return 0;
	end
-----------------
      semantic got imp_stmt, prod 0, @ 135-364, declarative pass
-----------------
if(argc = 0) then
		print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
	else
		float A = import(argc);
		A = A*argv;
		export(A);
		while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
		return 0;
	end
-----------------
     semantic got stmt, prod 1, @ 366-378, declarative pass
-----------------
string boop;
-----------------
      semantic got decl_stmt, prod 2, @ 366-378, declarative pass
-----------------
string boop;
-----------------
       semantic got var_decl, "boop", prod 0, @ 366-377, declarative pass
-----------------
string boop
-----------------
IR_next_name: returning [boop$2]
    semantic got stmt_list, prod 0, @ 118-378, imperative pass
-----------------
char C;
	int A;
	if(argc = 0) then
		print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
	else
		float A = import(argc);
		A = A*argv;
		export(A);
		while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
		return 0;
	end
	string boop;
-----------------
     semantic got stmt, prod 1, @ 118-125, imperative pass
-----------------
char C;
-----------------
      semantic got decl_stmt, prod 2, @ 118-125, imperative pass
-----------------
char C;
-----------------
       semantic got var_decl, "C", prod 0, @ 118-124, imperative pass
-----------------
char C
-----------------
     semantic got stmt, prod 1, @ 127-133, imperative pass
-----------------
int A;
-----------------
      semantic got decl_stmt, prod 2, @ 127-133, imperative pass
-----------------
int A;
-----------------
       semantic got var_decl, "A", prod 0, @ 127-132, imperative pass
-----------------
int A
-----------------
     semantic got stmt, prod 0, @ 135-364, imperative pass
-----------------
if(argc = 0) then
		print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
	else
		float A = import(argc);
		A = A*argv;
		export(A);
		while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
		return 0;
	end
-----------------
      semantic got imp_stmt, prod 0, @ 135-364, imperative pass
-----------------
if(argc = 0) then
		print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
	else
		float A = import(argc);
		A = A*argv;
		export(A);
		while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
		return 0;
	end
-----------------
       semantic got if_block, prod 1, @ 135-364, imperative pass
-----------------
if(argc = 0) then
		print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
	else
		float A = import(argc);
		A = A*argv;
		export(A);
		while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
		return 0;
	end
-----------------
        semantic got if_then, prod 0, @ 135-208, imperative pass
-----------------
if(argc = 0) then
		print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
-----------------
IR_next_name: returning [ST$8]
IR_next_name: returning [CS$5]
         semantic got expr_=, prod 0, @ 138-146, imperative pass
-----------------
argc = 0
-----------------
          semantic got expr_id, "argc", prod 0, @ 138-142, imperative pass
-----------------
argc
-----------------
found symbol 'argc'->'ST$5'
          semantic got expr_const, "0", prod 0, @ 145-146, imperative pass
-----------------
0
-----------------
IR_next_name: returning [$reg$1]
emitting code segment CS$5
IR_next_name: returning [lbl$1]
IR_next_name: returning [ST$9]
IR_next_name: returning [CS$6]
         semantic got stmt_list, prod 0, @ 155-208, declarative pass
-----------------
print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
-----------------
          semantic got stmt, prod 0, @ 155-187, declarative pass
-----------------
print("usage: a.exe arg1 arg2");
-----------------
           semantic got imp_stmt, prod 2, @ 155-187, declarative pass
-----------------
print("usage: a.exe arg1 arg2");
-----------------
          semantic got stmt, prod 0, @ 190-196, declarative pass
-----------------
A = 5;
-----------------
           semantic got imp_stmt, prod 2, @ 190-196, declarative pass
-----------------
A = 5;
-----------------
          semantic got stmt, prod 0, @ 199-208, declarative pass
-----------------
return 1;
-----------------
           semantic got imp_stmt, prod 4, @ 199-208, declarative pass
-----------------
return 1;
-----------------
         semantic got stmt_list, prod 0, @ 155-208, imperative pass
-----------------
print("usage: a.exe arg1 arg2");
		A = 5;
		return 1;
-----------------
          semantic got stmt, prod 0, @ 155-187, imperative pass
-----------------
print("usage: a.exe arg1 arg2");
-----------------
           semantic got imp_stmt, prod 2, @ 155-187, imperative pass
-----------------
print("usage: a.exe arg1 arg2");
-----------------
            semantic got expr_call, prod 0, @ 155-186, imperative pass
-----------------
print("usage: a.exe arg1 arg2")
-----------------
             semantic got expr_id, "print", prod 0, @ 155-160, imperative pass
-----------------
print
-----------------
found symbol 'print'->'ST$1'
found symbol 'print$1'->'ST$1'
             semantic got expr_const, ""usage: a.exe arg1 arg2"", prod 5, @ 161-185, imperative pass
-----------------
"usage: a.exe arg1 arg2"
-----------------
IR_next_name: returning [$reg$2]
IR_next_name: returning [$reg$3]
          semantic got stmt, prod 0, @ 190-196, imperative pass
-----------------
A = 5;
-----------------
           semantic got imp_stmt, prod 2, @ 190-196, imperative pass
-----------------
A = 5;
-----------------
            semantic got expr_=, prod 0, @ 190-195, imperative pass
-----------------
A = 5
-----------------
             semantic got expr_id, "A", prod 0, @ 190-191, imperative pass
-----------------
A
-----------------
found symbol 'A'->'ST$5'
             semantic got expr_const, "5", prod 0, @ 194-195, imperative pass
-----------------
5
-----------------
IR_next_name: returning [$reg$4]
          semantic got stmt, prod 0, @ 199-208, imperative pass
-----------------
return 1;
-----------------
           semantic got imp_stmt, prod 4, @ 199-208, imperative pass
-----------------
return 1;
-----------------
            semantic got expr_const, "1", prod 0, @ 206-207, imperative pass
-----------------
1
-----------------
IR_next_name: returning [$reg$5]
emitting code segment CS$6
IR_next_name: returning [ST$10]
IR_next_name: returning [CS$7]
        semantic got stmt_list, prod 0, @ 217-359, declarative pass
-----------------
float A = import(argc);
		A = A*argv;
		export(A);
		while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
		return 0;
-----------------
         semantic got stmt, prod 1, @ 217-240, declarative pass
-----------------
float A = import(argc);
-----------------
          semantic got decl_stmt, prod 2, @ 217-240, declarative pass
-----------------
float A = import(argc);
-----------------
           semantic got var_decl_assign, "A", prod 1, @ 217-239, declarative pass
-----------------
float A = import(argc)
-----------------
IR_next_name: returning [A$2]
         semantic got stmt, prod 0, @ 243-254, declarative pass
-----------------
A = A*argv;
-----------------
          semantic got imp_stmt, prod 2, @ 243-254, declarative pass
-----------------
A = A*argv;
-----------------
         semantic got stmt, prod 0, @ 257-267, declarative pass
-----------------
export(A);
-----------------
          semantic got imp_stmt, prod 2, @ 257-267, declarative pass
-----------------
export(A);
-----------------
         semantic got stmt, prod 0, @ 270-347, declarative pass
-----------------
while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
-----------------
          semantic got imp_stmt, prod 1, @ 270-347, declarative pass
-----------------
while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
-----------------
         semantic got stmt, prod 0, @ 350-359, declarative pass
-----------------
return 0;
-----------------
          semantic got imp_stmt, prod 4, @ 350-359, declarative pass
-----------------
return 0;
-----------------
        semantic got stmt_list, prod 0, @ 217-359, imperative pass
-----------------
float A = import(argc);
		A = A*argv;
		export(A);
		while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
		return 0;
-----------------
         semantic got stmt, prod 1, @ 217-240, imperative pass
-----------------
float A = import(argc);
-----------------
          semantic got decl_stmt, prod 2, @ 217-240, imperative pass
-----------------
float A = import(argc);
-----------------
           semantic got var_decl_assign, "A", prod 1, @ 217-239, imperative pass
-----------------
float A = import(argc)
-----------------
         semantic got stmt, prod 0, @ 243-254, imperative pass
-----------------
A = A*argv;
-----------------
          semantic got imp_stmt, prod 2, @ 243-254, imperative pass
-----------------
A = A*argv;
-----------------
           semantic got expr_=, prod 0, @ 243-253, imperative pass
-----------------
A = A*argv
-----------------
            semantic got expr_id, "A", prod 0, @ 243-244, imperative pass
-----------------
A
-----------------
found symbol 'A'->'ST$10'
            semantic got expr_*, prod 0, @ 247-253, imperative pass
-----------------
A*argv
-----------------
             semantic got expr_id, "A", prod 0, @ 247-248, imperative pass
-----------------
A
-----------------
found symbol 'A'->'ST$10'
             semantic got expr_id, "argv", prod 0, @ 249-253, imperative pass
-----------------
argv
-----------------
found symbol 'argv'->'ST$5'
IR_next_name: returning [$reg$6]
         semantic got stmt, prod 0, @ 257-267, imperative pass
-----------------
export(A);
-----------------
          semantic got imp_stmt, prod 2, @ 257-267, imperative pass
-----------------
export(A);
-----------------
           semantic got expr_call, prod 0, @ 257-266, imperative pass
-----------------
export(A)
-----------------
            semantic got expr_id, "export", prod 0, @ 257-263, imperative pass
-----------------
export
-----------------
found symbol 'export'->'ST$1'
found symbol 'export$1'->'ST$1'
            semantic got expr_id, "A", prod 0, @ 264-265, imperative pass
-----------------
A
-----------------
found symbol 'A'->'ST$10'
IR_next_name: returning [$reg$7]
         semantic got stmt, prod 0, @ 270-347, imperative pass
-----------------
while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
-----------------
          semantic got imp_stmt, prod 1, @ 270-347, imperative pass
-----------------
while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
-----------------
           semantic got while_loop, prod 0, @ 270-347, imperative pass
-----------------
while(A)
			print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
		end
-----------------
            semantic got expr_id, "A", prod 0, @ 276-277, imperative pass
-----------------
A
-----------------
found symbol 'A'->'ST$10'
IR_next_name: returning [lbl$2]
IR_next_name: returning [lbl$3]
IR_next_name: returning [ST$11]
IR_next_name: returning [CS$8]
            semantic got stmt_list, prod 0, @ 282-341, imperative pass
-----------------
print(A, argc);
			A = A/1;
			if(A = 1) then return 1; end
-----------------
             semantic got stmt, prod 0, @ 282-297, imperative pass
-----------------
print(A, argc);
-----------------
              semantic got imp_stmt, prod 2, @ 282-297, imperative pass
-----------------
print(A, argc);
-----------------
               semantic got expr_call, prod 0, @ 282-296, imperative pass
-----------------
print(A, argc)
-----------------
                semantic got expr_id, "print", prod 0, @ 282-287, imperative pass
-----------------
print
-----------------
found symbol 'print'->'ST$1'
found symbol 'print$1'->'ST$1'
                semantic got expr_id, "A", prod 0, @ 288-289, imperative pass
-----------------
A
-----------------
found symbol 'A'->'ST$10'
                semantic got expr_id, "argc", prod 0, @ 291-295, imperative pass
-----------------
argc
-----------------
found symbol 'argc'->'ST$5'
IR_next_name: returning [$reg$8]
             semantic got stmt, prod 0, @ 301-309, imperative pass
-----------------
A = A/1;
-----------------
              semantic got imp_stmt, prod 2, @ 301-309, imperative pass
-----------------
A = A/1;
-----------------
               semantic got expr_=, prod 0, @ 301-308, imperative pass
-----------------
A = A/1
-----------------
                semantic got expr_id, "A", prod 0, @ 301-302, imperative pass
-----------------
A
-----------------
found symbol 'A'->'ST$10'
                semantic got expr_/, prod 0, @ 305-308, imperative pass
-----------------
A/1
-----------------
                 semantic got expr_id, "A", prod 0, @ 305-306, imperative pass
-----------------
A
-----------------
found symbol 'A'->'ST$10'
                 semantic got expr_const, "1", prod 0, @ 307-308, imperative pass
-----------------
1
-----------------
IR_next_name: returning [$reg$9]
IR_next_name: returning [$reg$10]
             semantic got stmt, prod 0, @ 313-341, imperative pass
-----------------
if(A = 1) then return 1; end
-----------------
              semantic got imp_stmt, prod 0, @ 313-341, imperative pass
-----------------
if(A = 1) then return 1; end
-----------------
               semantic got if_block, prod 0, @ 313-341, imperative pass
-----------------
if(A = 1) then return 1; end
-----------------
                semantic got if_then, prod 0, @ 313-337, imperative pass
-----------------
if(A = 1) then return 1;
-----------------
IR_next_name: returning [ST$12]
IR_next_name: returning [CS$9]
                 semantic got expr_=, prod 0, @ 316-321, imperative pass
-----------------
A = 1
-----------------
                  semantic got expr_id, "A", prod 0, @ 316-317, imperative pass
-----------------
A
-----------------
found symbol 'A'->'ST$10'
                  semantic got expr_const, "1", prod 0, @ 320-321, imperative pass
-----------------
1
-----------------
IR_next_name: returning [$reg$11]
emitting code segment CS$9
IR_next_name: returning [lbl$4]
IR_next_name: returning [ST$13]
IR_next_name: returning [CS$10]
                 semantic got stmt_list, prod 0, @ 328-337, declarative pass
-----------------
return 1;
-----------------
                  semantic got stmt, prod 0, @ 328-337, declarative pass
-----------------
return 1;
-----------------
                   semantic got imp_stmt, prod 4, @ 328-337, declarative pass
-----------------
return 1;
-----------------
                 semantic got stmt_list, prod 0, @ 328-337, imperative pass
-----------------
return 1;
-----------------
                  semantic got stmt, prod 0, @ 328-337, imperative pass
-----------------
return 1;
-----------------
                   semantic got imp_stmt, prod 4, @ 328-337, imperative pass
-----------------
return 1;
-----------------
                    semantic got expr_const, "1", prod 0, @ 335-336, imperative pass
-----------------
1
-----------------
IR_next_name: returning [$reg$12]
emitting code segment CS$10
emitting code segment CS$8
         semantic got stmt, prod 0, @ 350-359, imperative pass
-----------------
return 0;
-----------------
          semantic got imp_stmt, prod 4, @ 350-359, imperative pass
-----------------
return 0;
-----------------
           semantic got expr_const, "0", prod 0, @ 357-358, imperative pass
-----------------
0
-----------------
IR_next_name: returning [$reg$13]
emitting code segment CS$7
     semantic got stmt, prod 1, @ 366-378, imperative pass
-----------------
string boop;
-----------------
      semantic got decl_stmt, prod 2, @ 366-378, imperative pass
-----------------
string boop;
-----------------
       semantic got var_decl, "boop", prod 0, @ 366-377, imperative pass
-----------------
string boop
-----------------
  semantic got decl_stmt, prod 0, @ 384-453, imperative pass
-----------------
class horse
	float fluff = 5;
	int boop()
		fluff = fluff+1;
	end
end
-----------------
   semantic got class_def, "horse", prod 0, @ 384-453, imperative pass
-----------------
class horse
	float fluff = 5;
	int boop()
		fluff = fluff+1;
	end
end
-----------------
found symbol 'horse'->'ST$1'
    semantic got decl_stmt_list, prod 0, @ 397-449, imperative pass
-----------------
float fluff = 5;
	int boop()
		fluff = fluff+1;
	end
-----------------
     semantic got decl_stmt, prod 2, @ 397-413, imperative pass
-----------------
float fluff = 5;
-----------------
      semantic got var_decl_assign, "fluff", prod 1, @ 397-412, imperative pass
-----------------
float fluff = 5
-----------------
     semantic got decl_stmt, prod 1, @ 415-449, imperative pass
-----------------
int boop()
		fluff = fluff+1;
	end
-----------------
      semantic got func_def, "boop", prod 0, @ 415-449, imperative pass
-----------------
int boop()
		fluff = fluff+1;
	end
-----------------
found symbol 'boop'->'ST$6'
IR_next_name: returning [CS$11]
       semantic got stmt_list, prod 0, @ 428-444, declarative pass
-----------------
fluff = fluff+1;
-----------------
        semantic got stmt, prod 0, @ 428-444, declarative pass
-----------------
fluff = fluff+1;
-----------------
         semantic got imp_stmt, prod 2, @ 428-444, declarative pass
-----------------
fluff = fluff+1;
-----------------
       semantic got stmt_list, prod 0, @ 428-444, imperative pass
-----------------
fluff = fluff+1;
-----------------
        semantic got stmt, prod 0, @ 428-444, imperative pass
-----------------
fluff = fluff+1;
-----------------
         semantic got imp_stmt, prod 2, @ 428-444, imperative pass
-----------------
fluff = fluff+1;
-----------------
          semantic got expr_=, prod 0, @ 428-443, imperative pass
-----------------
fluff = fluff+1
-----------------
           semantic got expr_id, "fluff", prod 0, @ 428-433, imperative pass
-----------------
fluff
-----------------
found symbol 'fluff'->'ST$6'
           semantic got expr_+, prod 0, @ 436-443, imperative pass
-----------------
fluff+1
-----------------
            semantic got expr_id, "fluff", prod 0, @ 436-441, imperative pass
-----------------
fluff
-----------------
found symbol 'fluff'->'ST$6'
            semantic got expr_const, "1", prod 0, @ 442-443, imperative pass
-----------------
1
-----------------
IR_next_name: returning [$reg$14]
IR_next_name: returning [$reg$15]
found symbol 'main'->'ST$1'
emitting code segment CS$1
emitting code segment CS$2
emitting code segment CS$3
emitting code segment CS$11
semantic: done

PRINTING SEMANTIC
printing symbol tables (1):
Symbol table 'ST$1':
symbol	name	ir_name	type	scope	code	pos
function	import	import$1	int	ST$2	CS$1	
function	export	export$1	int	ST$3	CS$2	
function	print	print$1	int	ST$4	CS$3	
function	main	main$1	int	ST$5	CS$4	
class	horse	horse$1		ST$6		
parameter	arg	arg$1	int			0
parameter	arg	arg$2	int			0
parameter	str	str$1	string			0
parameter	argc	argc$1	int			0
parameter	argv	argv$1	int			1
variable	C	C$1	char			
variable	A	A$1	int			
variable	boop	boop$2	string			
variable	fluff	fluff$1	float			
function	boop	boop$1	int	ST$7	CS$11	
variable	A	A$2	float			
printing code segments (1):
code segment 'CS$4'->'ST$5'
  /* int main(int argc, int argv) */
  LABEL main
  /* if(argc = 0) */
    MOV argc$1 0
  IFNOT argc$1 lbl$1
  /* then */
    /* print("usage: a.exe arg1 arg2"); */
    CALL $reg$3 print$1 "usage: a.exe arg1 arg2"
    /* A = 5; */
    MOV A$1 5
    /* return 1; */
    RETURN 1
  LABEL lbl$1
  /* else */
    /* A = A*argv; */
    MULTIPLY $reg$6 A$2 argv$1
    MOV A$2 $reg$6
    /* export(A); */
    CALL $reg$7 export$1 A$2
    /* while(A) */
    LABEL lbl$2
    IFNOT A$2 lbl$3
       /* print(A, argc); */
       CALL $reg$8 print$1 A$2 argc$1
       /* A = A/1; */
       DIVIDE $reg$10 A$2 1
       MOV A$2 $reg$10
       /* if(A = 1) */
           MOV A$2 1
       IFNOT A$2 lbl$4
       /* then */
           /* return 1; */
           RETURN 1
       LABEL lbl$4
       /* end */
    GOTO lbl$2
    LABEL lbl$3
    /* end */
    /* return 0; */
    RETURN 0
  /* end */
  RETURN
  /* end */
   /* int import(int arg) */
   LABEL import
   RETURN
   /* end */
   /* int export(int arg) */
   LABEL export
   /* return arg; */
   RETURN arg$2
   RETURN
   /* end */
   /* int print(string str) */
   LABEL print
   RETURN
   /* end */
   /* int boop() */
   LABEL boop
   /* fluff = fluff+1; */
   ADD $reg$15 fluff$1 1
   MOV fluff$1 $reg$15
   RETURN
   /* end */
end code segment

GOOD BYE
[Inferior 1 (process 2216) exited normally]
(gdb) (gdb) quit
