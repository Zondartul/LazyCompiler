GNU gdb (GDB) 7.6.1
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "mingw32".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from C:\Stride\LazyComp\data\a.exe...done.
(gdb) Starting program: C:\Stride\LazyComp\data/a.exe lazy2.txt
[New Thread 2180.0xb44]
sizeof ast_node = '76'
test diff = '4', size = '4'
Lexxed token [int]
num allocs: 5, mem used: 25306
node "typename": [int] (0/0)
Lexxed token [import]
num allocs: 8, mem used: 25390
Lexxed token [(]
num allocs: 9, mem used: 25397
Lexxed token [int]
num allocs: 9, mem used: 25397
node "typename": [int] (0/0)
Lexxed token [arg]
num allocs: 11, mem used: 25485
Lexxed token [)]
num allocs: 12, mem used: 25489
node "var_decl": [arg] (0/1)
node "var_decl_list_ne": [(null)] (1/1)
node "var_decl_list": [(null)] (0/1)
unroll [var_decl_list]  unroll done
Lexxed token [end]
num allocs: 18, mem used: 25741
node "stmt_list": [<empty>] (1/0)
FUNC_DEF ID = [import]
node "func_def": [import] (0/3)
node "decl_stmt": [(null)] (1/1)
node "decl_stmt_list_ne": [(null)] (1/1)
Lexxed token [int]
num allocs: 25, mem used: 26081
node "typename": [int] (0/0)
Lexxed token [export]
num allocs: 27, mem used: 26161
Lexxed token [(]
num allocs: 28, mem used: 26168
Lexxed token [int]
num allocs: 28, mem used: 26168
node "typename": [int] (0/0)
Lexxed token [arg]
num allocs: 30, mem used: 26272
Lexxed token [)]
num allocs: 31, mem used: 26276
node "var_decl": [arg] (0/1)
node "var_decl_list_ne": [(null)] (1/1)
node "var_decl_list": [(null)] (0/1)
unroll [var_decl_list]  unroll done
Lexxed token [end]
num allocs: 37, mem used: 26516
node "stmt_list": [<empty>] (1/0)
FUNC_DEF ID = [export]
node "func_def": [export] (0/3)
node "decl_stmt": [(null)] (1/1)
node "decl_stmt_list_ne": [(null)] (0/2)
Lexxed token [int]
num allocs: 44, mem used: 26884
node "typename": [int] (0/0)
Lexxed token [print]
num allocs: 46, mem used: 26964
Lexxed token [(]
num allocs: 47, mem used: 26970
Lexxed token [string]
num allocs: 47, mem used: 26970
node "typename": [string] (0/0)
Lexxed token [str]
num allocs: 49, mem used: 27053
Lexxed token [)]
num allocs: 50, mem used: 27057
node "var_decl": [str] (0/1)
node "var_decl_list_ne": [(null)] (1/1)
node "var_decl_list": [(null)] (0/1)
unroll [var_decl_list]  unroll done
Lexxed token [end]
num allocs: 56, mem used: 27297
node "stmt_list": [<empty>] (1/0)
FUNC_DEF ID = [print]
node "func_def": [print] (0/3)
node "decl_stmt": [(null)] (1/1)
node "decl_stmt_list_ne": [(null)] (0/2)
Lexxed token [int]
num allocs: 63, mem used: 27685
node "typename": [int] (0/0)
Lexxed token [main]
num allocs: 65, mem used: 27765
Lexxed token [(]
num allocs: 66, mem used: 27770
Lexxed token [int]
num allocs: 66, mem used: 27770
node "typename": [int] (0/0)
Lexxed token [argc]
num allocs: 68, mem used: 27850
Lexxed token [,]
num allocs: 69, mem used: 27855
node "var_decl": [argc] (0/1)
node "var_decl_list_ne": [(null)] (1/1)
Lexxed token [int]
num allocs: 73, mem used: 28015
node "typename": [int] (0/0)
Lexxed token [argv]
num allocs: 75, mem used: 28095
Lexxed token [)]
num allocs: 76, mem used: 28100
node "var_decl": [argv] (0/1)
node "var_decl_list_ne": [(null)] (0/2)
node "var_decl_list": [(null)] (0/1)
unroll [var_decl_list]  unroll done
Lexxed token [char]
num allocs: 82, mem used: 28356
node "typename": [char] (0/0)
Lexxed token [C]
num allocs: 84, mem used: 28437
Lexxed token [;]
num allocs: 85, mem used: 28439
node "var_decl": [C] (0/1)
node "decl_stmt": [(null)] (2/1)
node "stmt": [(null)] (1/1)
node "stmt_list_ne": [(null)] (1/1)
Lexxed token [if]
num allocs: 93, mem used: 28843
Lexxed token [(]
num allocs: 93, mem used: 28843
Lexxed token [argc]
num allocs: 93, mem used: 28843
node "expr_id": [argc] (0/0)
Lexxed token [=]
num allocs: 95, mem used: 28924
Lexxed token [0]
num allocs: 95, mem used: 28924
node "expr_const": [0] (0/0)
Lexxed token [)]
num allocs: 97, mem used: 29002
node "expr_=": [(null)] (0/2)
Lexxed token [then]
num allocs: 99, mem used: 29090
Lexxed token [print]
num allocs: 99, mem used: 29090
node "expr_id": [print] (0/0)
Lexxed token [(]
num allocs: 101, mem used: 29172
Lexxed token ["usage: a.exe arg1 arg2"]
num allocs: 101, mem used: 29172
node "expr_const": ["usage: a.exe arg1 arg2"] (5/0)
Lexxed token [)]
num allocs: 103, mem used: 29273
node "expr_list_ne": [(null)] (1/1)
node "expr_list": [(null)] (0/1)
unroll [expr_list]  unroll done
node "expr_call": [(null)] (0/2)
Lexxed token [;]
num allocs: 109, mem used: 29521
node "imp_stmt": [(null)] (2/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (1/1)
Lexxed token [return]
num allocs: 115, mem used: 29761
Lexxed token [1]
num allocs: 115, mem used: 29761
node "expr_const": [1] (0/0)
Lexxed token [;]
num allocs: 117, mem used: 29839
node "imp_stmt": [(null)] (4/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
Lexxed token [else]
num allocs: 123, mem used: 30087
node "stmt_list": [(null)] (0/1)
unroll [stmt_list]  unroll done
node "if_then": [(null)] (0/2)
Lexxed token [float]
num allocs: 127, mem used: 30263
node "typename": [float] (0/0)
Lexxed token [A]
num allocs: 129, mem used: 30345
Lexxed token [=]
num allocs: 130, mem used: 30347
Lexxed token [import]
num allocs: 130, mem used: 30347
node "expr_id": [import] (0/0)
Lexxed token [(]
num allocs: 132, mem used: 30430
Lexxed token [argc]
num allocs: 132, mem used: 30430
node "expr_id": [argc] (0/0)
Lexxed token [)]
num allocs: 134, mem used: 30511
node "expr_list_ne": [(null)] (1/1)
node "expr_list": [(null)] (0/1)
unroll [expr_list]  unroll done
node "expr_call": [(null)] (0/2)
Lexxed token [;]
num allocs: 140, mem used: 30883
node "var_decl_assign": [A] (1/2)
node "decl_stmt": [(null)] (2/1)
node "stmt": [(null)] (1/1)
node "stmt_list_ne": [(null)] (1/1)
Lexxed token [A]
num allocs: 148, mem used: 31211
node "expr_id": [A] (0/0)
Lexxed token [=]
num allocs: 150, mem used: 31289
Lexxed token [A]
num allocs: 150, mem used: 31289
node "expr_id": [A] (0/0)
Lexxed token [*]
num allocs: 152, mem used: 31367
Lexxed token [argv]
num allocs: 152, mem used: 31367
node "expr_id": [argv] (0/0)
Lexxed token [;]
num allocs: 154, mem used: 31448
node "expr_*": [(null)] (0/2)
node "expr_=": [(null)] (0/2)
node "imp_stmt": [(null)] (2/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
Lexxed token [export]
num allocs: 164, mem used: 31872
node "expr_id": [export] (0/0)
Lexxed token [(]
num allocs: 166, mem used: 31955
Lexxed token [A]
num allocs: 166, mem used: 31955
node "expr_id": [A] (0/0)
Lexxed token [)]
num allocs: 168, mem used: 32033
node "expr_list_ne": [(null)] (1/1)
node "expr_list": [(null)] (0/1)
unroll [expr_list]  unroll done
node "expr_call": [(null)] (0/2)
Lexxed token [;]
num allocs: 174, mem used: 32281
node "imp_stmt": [(null)] (2/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
Lexxed token [while]
num allocs: 180, mem used: 32529
Lexxed token [(]
num allocs: 180, mem used: 32529
Lexxed token [A]
num allocs: 180, mem used: 32529
node "expr_id": [A] (0/0)
Lexxed token [)]
num allocs: 182, mem used: 32607
Lexxed token [print]
num allocs: 182, mem used: 32607
node "expr_id": [print] (0/0)
Lexxed token [(]
num allocs: 184, mem used: 32689
Lexxed token [A]
num allocs: 184, mem used: 32689
node "expr_id": [A] (0/0)
Lexxed token [)]
num allocs: 186, mem used: 32767
node "expr_list_ne": [(null)] (1/1)
node "expr_list": [(null)] (0/1)
unroll [expr_list]  unroll done
node "expr_call": [(null)] (0/2)
Lexxed token [;]
num allocs: 192, mem used: 33015
node "imp_stmt": [(null)] (2/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (1/1)
Lexxed token [A]
num allocs: 198, mem used: 33443
node "expr_id": [A] (0/0)
Lexxed token [=]
num allocs: 200, mem used: 33521
Lexxed token [A]
num allocs: 200, mem used: 33521
node "expr_id": [A] (0/0)
Lexxed token [/]
num allocs: 202, mem used: 33599
Lexxed token [1]
num allocs: 202, mem used: 33599
node "expr_const": [1] (0/0)
Lexxed token [;]
num allocs: 204, mem used: 33677
node "expr_/": [(null)] (0/2)
node "expr_=": [(null)] (0/2)
node "imp_stmt": [(null)] (2/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
Lexxed token [if]
num allocs: 214, mem used: 34101
Lexxed token [(]
num allocs: 214, mem used: 34101
Lexxed token [A]
num allocs: 214, mem used: 34101
node "expr_id": [A] (0/0)
Lexxed token [=]
num allocs: 216, mem used: 34179
Lexxed token [1]
num allocs: 216, mem used: 34179
node "expr_const": [1] (0/0)
Lexxed token [)]
num allocs: 218, mem used: 34257
node "expr_=": [(null)] (0/2)
Lexxed token [then]
num allocs: 220, mem used: 34345
Lexxed token [return]
num allocs: 220, mem used: 34345
Lexxed token [1]
num allocs: 220, mem used: 34345
node "expr_const": [1] (0/0)
Lexxed token [;]
num allocs: 222, mem used: 34423
node "imp_stmt": [(null)] (4/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (1/1)
Lexxed token [end]
num allocs: 228, mem used: 34663
node "stmt_list": [(null)] (0/1)
unroll [stmt_list]  unroll done
node "if_then": [(null)] (0/2)
node "if_block": [(null)] (0/1)
node "imp_stmt": [(null)] (0/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
Lexxed token [end]
num allocs: 240, mem used: 35159
node "stmt_list": [(null)] (0/1)
unroll [stmt_list]  unroll done
node "while_loop": [(null)] (0/2)
node "imp_stmt": [(null)] (1/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
Lexxed token [return]
num allocs: 250, mem used: 35583
Lexxed token [0]
num allocs: 250, mem used: 35583
node "expr_const": [0] (0/0)
Lexxed token [;]
num allocs: 252, mem used: 35661
node "imp_stmt": [(null)] (4/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
Lexxed token [end]
num allocs: 258, mem used: 35909
node "stmt_list": [(null)] (0/1)
unroll [stmt_list]  unroll done
node "if_block": [(null)] (1/2)
node "imp_stmt": [(null)] (0/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (0/2)
Lexxed token [string]
num allocs: 268, mem used: 36369
node "typename": [string] (0/0)
Lexxed token [boop]
num allocs: 270, mem used: 36452
Lexxed token [;]
num allocs: 271, mem used: 36457
node "var_decl": [boop] (0/1)
node "decl_stmt": [(null)] (2/1)
node "stmt": [(null)] (1/1)
node "stmt_list_ne": [(null)] (0/2)
Lexxed token [end]
num allocs: 279, mem used: 36785
node "stmt_list": [(null)] (0/1)
unroll [stmt_list]  unroll done
FUNC_DEF ID = [main]
node "func_def": [main] (0/3)
node "decl_stmt": [(null)] (1/1)
node "decl_stmt_list_ne": [(null)] (0/2)
Lexxed token [class]
num allocs: 287, mem used: 37129
Lexxed token [horse]
num allocs: 287, mem used: 37129
Lexxed token [float]
num allocs: 288, mem used: 37135
node "typename": [float] (0/0)
Lexxed token [fluff]
num allocs: 290, mem used: 37217
Lexxed token [=]
num allocs: 291, mem used: 37223
Lexxed token [5]
num allocs: 291, mem used: 37223
node "expr_const": [5] (0/0)
Lexxed token [;]
num allocs: 293, mem used: 37301
node "var_decl_assign": [fluff] (1/2)
node "decl_stmt": [(null)] (2/1)
node "decl_stmt_list_ne": [(null)] (1/1)
Lexxed token [int]
num allocs: 299, mem used: 37829
node "typename": [int] (0/0)
Lexxed token [boop]
num allocs: 301, mem used: 37909
Lexxed token [(]
num allocs: 302, mem used: 37914
Lexxed token [)]
num allocs: 302, mem used: 37914
node "var_decl_list": [<empty>] (1/0)
Lexxed token [fluff]
num allocs: 303, mem used: 37990
node "expr_id": [fluff] (0/0)
Lexxed token [=]
num allocs: 305, mem used: 38072
Lexxed token [fluff]
num allocs: 305, mem used: 38072
node "expr_id": [fluff] (0/0)
Lexxed token [+]
num allocs: 307, mem used: 38154
Lexxed token [1]
num allocs: 307, mem used: 38154
node "expr_const": [1] (0/0)
Lexxed token [;]
num allocs: 309, mem used: 38232
node "expr_+": [(null)] (0/2)
node "expr_=": [(null)] (0/2)
node "imp_stmt": [(null)] (2/1)
node "stmt": [(null)] (0/1)
node "stmt_list_ne": [(null)] (1/1)
Lexxed token [end]
num allocs: 319, mem used: 38648
node "stmt_list": [(null)] (0/1)
unroll [stmt_list]  unroll done
FUNC_DEF ID = [boop]
node "func_def": [boop] (0/3)
node "decl_stmt": [(null)] (1/1)
node "decl_stmt_list_ne": [(null)] (0/2)
Lexxed token [end]
num allocs: 327, mem used: 38984
node "decl_stmt_list": [(null)] (0/1)
unroll [decl_stmt_list]  unroll done
FUNC_DEF ID = [horse]
node "class_def": [horse] (0/1)
node "decl_stmt": [(null)] (0/1)
node "decl_stmt_list_ne": [(null)] (0/2)
node "decl_stmt_list": [(null)] (0/1)
unroll [decl_stmt_list]  unroll done
node "program": [(null)] (0/1)

PARSING DONE
printing ast 00B3E398, 761729A0, 0, [program]
printing ast 00B3E280, 761729A0, 0, [decl_stmt_list]
printing ast 00B38BA0, 761729A0, 0, [decl_stmt]
printing ast 00B38AD0, 761729A0, 0, [func_def]
printing ast 00B31180, 761729A0, 0, [typename]
printing ast 00B313C0, 761729A0, 1, [var_decl_list]
printing ast 00B312B0, 761729A0, 0, [var_decl]
printing ast 00B31228, 761729A0, 0, [typename]
printing ast 00B38A68, 761729A0, 2, [stmt_list]
printing ast 00B39088, 761729A0, 1, [decl_stmt]
printing ast 00B38FF8, 761729A0, 0, [func_def]
printing ast 00B38CB0, 761729A0, 0, [typename]
printing ast 00B38F08, 761729A0, 1, [var_decl_list]
printing ast 00B38E18, 761729A0, 0, [var_decl]
printing ast 00B38D58, 761729A0, 0, [typename]
printing ast 00B38F90, 761729A0, 2, [stmt_list]
printing ast 00B395B8, 761729A0, 2, [decl_stmt]
printing ast 00B39528, 761729A0, 0, [func_def]
printing ast 00B391F8, 761729A0, 0, [typename]
printing ast 00B39438, 761729A0, 1, [var_decl_list]
printing ast 00B39328, 761729A0, 0, [var_decl]
printing ast 00B392A0, 761729A0, 0, [typename]
printing ast 00B394C0, 761729A0, 2, [stmt_list]
printing ast 00B3D3A0, 761729A0, 3, [decl_stmt]
printing ast 00B3D310, 761729A0, 0, [func_def]
printing ast 00B39740, 761729A0, 0, [typename]
printing ast 00B39B40, 761729A0, 1, [var_decl_list]
printing ast 00B39870, 761729A0, 0, [var_decl]
printing ast 00B397E8, 761729A0, 0, [typename]
printing ast 00B39A28, 761729A0, 1, [var_decl]
printing ast 00B399A0, 761729A0, 0, [typename]
printing ast 00B3D280, 761729A0, 2, [stmt_list]
printing ast 00B39D88, 761729A0, 0, [stmt]
printing ast 00B39D00, 761729A0, 0, [decl_stmt]
printing ast 00B39C78, 761729A0, 0, [var_decl]
printing ast 00B39BF0, 761729A0, 0, [typename]
printing ast 00B3CEB8, 761729A0, 1, [stmt]
printing ast 00B3CE50, 761729A0, 0, [imp_stmt]
printing ast 00B3CDE8, 761729A0, 0, [if_block]
printing ast 00B3A7B0, 761729A0, 0, [if_then]
printing ast 00B3A050, 761729A0, 0, [expr_=]
printing ast 00B39640, 761729A0, 0, [expr_id]
printing ast 00B39FE8, 761729A0, 1, [expr_const]
printing ast 00B3A720, 761729A0, 1, [stmt_list]
printing ast 00B3A3E8, 761729A0, 0, [stmt]
printing ast 00B3A360, 761729A0, 0, [imp_stmt]
printing ast 00B3A2D0, 761729A0, 0, [expr_call]
printing ast 00B3A0B8, 761729A0, 0, [expr_id]
printing ast 00B3A248, 761729A0, 1, [expr_list]
printing ast 00B3A158, 761729A0, 0, [expr_const]
printing ast 00B3A608, 761729A0, 1, [stmt]
printing ast 00B3A580, 761729A0, 0, [imp_stmt]
printing ast 00B3A518, 761729A0, 0, [expr_const]
printing ast 00B3CCD0, 761729A0, 1, [stmt_list]
printing ast 00B3AD48, 761729A0, 0, [stmt]
printing ast 00B3ACC0, 761729A0, 0, [decl_stmt]
printing ast 00B3AC30, 761729A0, 0, [var_decl_assign]
printing ast 00B3A860, 761729A0, 0, [typename]
printing ast 00B39F20, 761729A0, 1, [expr_call]
printing ast 00B3A908, 761729A0, 0, [expr_id]
printing ast 00B39E98, 761729A0, 1, [expr_list]
printing ast 00B3A990, 761729A0, 0, [expr_id]
printing ast 00B3B198, 761729A0, 1, [stmt]
printing ast 00B3B110, 761729A0, 0, [imp_stmt]
printing ast 00B3B080, 761729A0, 0, [expr_=]
printing ast 00B3AE78, 761729A0, 0, [expr_id]
printing ast 00B3AFF0, 761729A0, 1, [expr_*]
printing ast 00B3AF00, 761729A0, 0, [expr_id]
printing ast 00B3AF88, 761729A0, 1, [expr_id]
printing ast 00B3B5E8, 761729A0, 2, [stmt]
printing ast 00B3B560, 761729A0, 0, [imp_stmt]
printing ast 00B3B4D0, 761729A0, 0, [expr_call]
printing ast 00B3B2D0, 761729A0, 0, [expr_id]
printing ast 00B3B448, 761729A0, 1, [expr_list]
printing ast 00B3B358, 761729A0, 0, [expr_id]
printing ast 00B3C990, 761729A0, 3, [stmt]
printing ast 00B3C908, 761729A0, 0, [imp_stmt]
printing ast 00B3C878, 761729A0, 0, [while_loop]
printing ast 00B3B720, 761729A0, 0, [expr_id]
printing ast 00B3C7E8, 761729A0, 1, [stmt_list]
printing ast 00B3BAC0, 761729A0, 0, [stmt]
printing ast 00B3BA38, 761729A0, 0, [imp_stmt]
printing ast 00B3B9A8, 761729A0, 0, [expr_call]
printing ast 00B3B7A8, 761729A0, 0, [expr_id]
printing ast 00B3B920, 761729A0, 1, [expr_list]
printing ast 00B3B830, 761729A0, 0, [expr_id]
printing ast 00B3BFD0, 761729A0, 1, [stmt]
printing ast 00B3BF48, 761729A0, 0, [imp_stmt]
printing ast 00B3BEE0, 761729A0, 0, [expr_=]
printing ast 00B3AAA0, 761729A0, 0, [expr_id]
printing ast 00B3BE78, 761729A0, 1, [expr_/]
printing ast 00B3AB28, 761729A0, 0, [expr_id]
printing ast 00B3BE10, 761729A0, 1, [expr_const]
printing ast 00B3C6D0, 761729A0, 2, [stmt]
printing ast 00B3C648, 761729A0, 0, [imp_stmt]
printing ast 00B3C5C0, 761729A0, 0, [if_block]
printing ast 00B3C530, 761729A0, 0, [if_then]
printing ast 00B3C1F8, 761729A0, 0, [expr_=]
printing ast 00B3C108, 761729A0, 0, [expr_id]
printing ast 00B3C190, 761729A0, 1, [expr_const]
printing ast 00B3C4A8, 761729A0, 1, [stmt_list]
printing ast 00B3C398, 761729A0, 0, [stmt]
printing ast 00B3C310, 761729A0, 0, [imp_stmt]
printing ast 00B3C2A8, 761729A0, 0, [expr_const]
printing ast 00B3CBB8, 761729A0, 4, [stmt]
printing ast 00B3CB30, 761729A0, 0, [imp_stmt]
printing ast 00B3CAC8, 761729A0, 0, [expr_const]
printing ast 00B3D168, 761729A0, 2, [stmt]
printing ast 00B3D0E0, 761729A0, 0, [decl_stmt]
printing ast 00B3D058, 761729A0, 0, [var_decl]
printing ast 00B3CFD0, 761729A0, 0, [typename]
printing ast 00B3E168, 761729A0, 4, [decl_stmt]
printing ast 00B3E0E0, 761729A0, 0, [class_def]
printing ast 00B3E050, 761729A0, 0, [decl_stmt_list]
printing ast 00B3BBD0, 761729A0, 0, [decl_stmt]
printing ast 00B3D608, 761729A0, 0, [var_decl_assign]
printing ast 00B3D4F8, 761729A0, 0, [typename]
printing ast 00B3D5A0, 761729A0, 1, [expr_const]
printing ast 00B3DF38, 761729A0, 1, [decl_stmt]
printing ast 00B3DEA8, 761729A0, 0, [func_def]
printing ast 00B3BD00, 761729A0, 0, [typename]
printing ast 00B3BD88, 761729A0, 1, [var_decl_list]
printing ast 00B3DE20, 761729A0, 2, [stmt_list]
printing ast 00B3DD10, 761729A0, 0, [stmt]
printing ast 00B3DC88, 761729A0, 0, [imp_stmt]
printing ast 00B3DBF8, 761729A0, 0, [expr_=]
printing ast 00B3D9F0, 761729A0, 0, [expr_id]
printing ast 00B3DB68, 761729A0, 1, [expr_+]
printing ast 00B3DA78, 761729A0, 0, [expr_id]
printing ast 00B3DB00, 761729A0, 1, [expr_const]

PRINTING DONE
semantic got program, imperative pass
IR_next_name: returning [ST1]
 semantic got decl_stmt_list, declarative pass
  semantic got decl_stmt, declarative pass
   semantic got func_def, "import", declarative pass
IR_next_name: returning [ST2]
    semantic got var_decl_list, declarative pass
     semantic got var_decl, "arg", declarative pass
  semantic got decl_stmt, declarative pass
   semantic got func_def, "export", declarative pass
IR_next_name: returning [ST3]
    semantic got var_decl_list, declarative pass
     semantic got var_decl, "arg", declarative pass
  semantic got decl_stmt, declarative pass
   semantic got func_def, "print", declarative pass
IR_next_name: returning [ST4]
    semantic got var_decl_list, declarative pass
     semantic got var_decl, "str", declarative pass
  semantic got decl_stmt, declarative pass
   semantic got func_def, "main", declarative pass
IR_next_name: returning [ST5]
    semantic got var_decl_list, declarative pass
     semantic got var_decl, "argc", declarative pass
     semantic got var_decl, "argv", declarative pass
  semantic got decl_stmt, declarative pass
   semantic got class_def, "horse", declarative pass
IR_next_name: returning [ST6]
    semantic got decl_stmt_list, declarative pass
     semantic got decl_stmt, declarative pass
      semantic got var_decl_assign, "fluff", declarative pass
     semantic got decl_stmt, declarative pass
      semantic got func_def, "boop", declarative pass
IR_next_name: returning [ST7]
       semantic got var_decl_list, "<empty>", declarative pass
 semantic got decl_stmt_list, imperative pass
  semantic got decl_stmt, imperative pass
   semantic got func_def, "import", imperative pass
found symbol 'import'->'ST1'
IR_next_name: returning [CS1]
    semantic got stmt_list, "<empty>", imperative pass
  semantic got decl_stmt, imperative pass
   semantic got func_def, "export", imperative pass
found symbol 'export'->'ST1'
IR_next_name: returning [CS2]
    semantic got stmt_list, "<empty>", imperative pass
  semantic got decl_stmt, imperative pass
   semantic got func_def, "print", imperative pass
found symbol 'print'->'ST1'
IR_next_name: returning [CS3]
    semantic got stmt_list, "<empty>", imperative pass
  semantic got decl_stmt, imperative pass
   semantic got func_def, "main", imperative pass
found symbol 'main'->'ST1'
IR_next_name: returning [CS4]
    semantic got stmt_list, imperative pass
     semantic got stmt, imperative pass
      semantic got decl_stmt, imperative pass
       semantic got var_decl, "C", imperative pass
     semantic got stmt, imperative pass
      semantic got imp_stmt, imperative pass
       semantic got if_block, imperative pass
        semantic got if_then, imperative pass
         semantic got expr_=, imperative pass
          semantic got expr_id, "argc", imperative pass
          semantic got expr_const, "0", imperative pass
IR_next_name: returning [reg1]
IR_next_name: returning [lbl1]
IR_next_name: returning [ST8]
IR_next_name: returning [CS5]
         semantic got stmt_list, declarative pass
          semantic got stmt, declarative pass
           semantic got imp_stmt, declarative pass
          semantic got stmt, declarative pass
           semantic got imp_stmt, declarative pass
         semantic got stmt_list, imperative pass
          semantic got stmt, imperative pass
           semantic got imp_stmt, imperative pass
            semantic got expr_call, imperative pass
             semantic got expr_id, "print", imperative pass
          semantic got stmt, imperative pass
           semantic got imp_stmt, imperative pass
            semantic got expr_const, "1", imperative pass
IR_next_name: returning [reg2]
        semantic got stmt_list, imperative pass
         semantic got stmt, imperative pass
          semantic got decl_stmt, imperative pass
           semantic got var_decl_assign, "A", imperative pass
         semantic got stmt, imperative pass
          semantic got imp_stmt, imperative pass
           semantic got expr_=, imperative pass
            semantic got expr_id, "A", imperative pass
            semantic got expr_*, imperative pass
             semantic got expr_id, "A", imperative pass
             semantic got expr_id, "argv", imperative pass
IR_next_name: returning [reg3]
         semantic got stmt, imperative pass
          semantic got imp_stmt, imperative pass
           semantic got expr_call, imperative pass
            semantic got expr_id, "export", imperative pass
         semantic got stmt, imperative pass
          semantic got imp_stmt, imperative pass
           semantic got while_loop, imperative pass
            semantic got expr_id, "A", imperative pass
IR_next_name: returning [lbl2]
IR_next_name: returning [lbl3]
IR_next_name: returning [ST9]
IR_next_name: returning [CS6]
            semantic got stmt_list, imperative pass
             semantic got stmt, imperative pass
              semantic got imp_stmt, imperative pass
               semantic got expr_call, imperative pass
                semantic got expr_id, "print", imperative pass
             semantic got stmt, imperative pass
              semantic got imp_stmt, imperative pass
               semantic got expr_=, imperative pass
                semantic got expr_id, "A", imperative pass
                semantic got expr_/, imperative pass
                 semantic got expr_id, "A", imperative pass
                 semantic got expr_const, "1", imperative pass
IR_next_name: returning [reg4]
IR_next_name: returning [reg5]
             semantic got stmt, imperative pass
              semantic got imp_stmt, imperative pass
               semantic got if_block, imperative pass
                semantic got if_then, imperative pass
                 semantic got expr_=, imperative pass
                  semantic got expr_id, "A", imperative pass
                  semantic got expr_const, "1", imperative pass
IR_next_name: returning [reg6]
IR_next_name: returning [lbl4]
IR_next_name: returning [ST10]
IR_next_name: returning [CS7]
                 semantic got stmt_list, declarative pass
                  semantic got stmt, declarative pass
                   semantic got imp_stmt, declarative pass
                 semantic got stmt_list, imperative pass
                  semantic got stmt, imperative pass
                   semantic got imp_stmt, imperative pass
                    semantic got expr_const, "1", imperative pass
IR_next_name: returning [reg7]
         semantic got stmt, imperative pass
          semantic got imp_stmt, imperative pass
           semantic got expr_const, "0", imperative pass
IR_next_name: returning [reg8]
     semantic got stmt, imperative pass
      semantic got decl_stmt, imperative pass
       semantic got var_decl, "boop", imperative pass
  semantic got decl_stmt, imperative pass
   semantic got class_def, "horse", imperative pass
found symbol 'horse'->'ST1'
    semantic got decl_stmt_list, imperative pass
     semantic got decl_stmt, imperative pass
      semantic got var_decl_assign, "fluff", imperative pass
     semantic got decl_stmt, imperative pass
      semantic got func_def, "boop", imperative pass
found symbol 'boop'->'ST6'
IR_next_name: returning [CS8]
       semantic got stmt_list, imperative pass
        semantic got stmt, imperative pass
         semantic got imp_stmt, imperative pass
          semantic got expr_=, imperative pass
           semantic got expr_id, "fluff", imperative pass
           semantic got expr_+, imperative pass
            semantic got expr_id, "fluff", imperative pass
            semantic got expr_const, "1", imperative pass
IR_next_name: returning [reg9]
IR_next_name: returning [reg10]
semantic: done

PRINTING SEMANTIC
printing symbol tables (10):
Symbol table 'ST1':
symbol [import]: function
 type = int
 scope = ST2
 code = CS1
symbol [export]: function
 type = int
 scope = ST3
 code = CS2
symbol [print]: function
 type = int
 scope = ST4
 code = CS3
symbol [main]: function
 type = int
 scope = ST5
 code = CS4
symbol [horse]: class
 scope = ST6
End Symbol table
Symbol table 'ST2'->'ST1':
symbol [arg]: parameter
 type = int
 pos = 0
End Symbol table
Symbol table 'ST3'->'ST1':
symbol [arg]: parameter
 type = int
 pos = 0
End Symbol table
Symbol table 'ST4'->'ST1':
symbol [str]: parameter
 type = string
 pos = 0
End Symbol table
Symbol table 'ST5'->'ST1':
symbol [argc]: parameter
 type = int
 pos = 0
symbol [argv]: parameter
 type = int
 pos = 1
End Symbol table
Symbol table 'ST6'->'ST1':
symbol [fluff]: variable
 type = float
symbol [boop]: function
 type = int
 scope = ST7
 code = CS8
End Symbol table
Symbol table 'ST7'->'ST6':
End Symbol table
Symbol table 'ST8'->'ST5':
End Symbol table
Symbol table 'ST9'->'ST5':
End Symbol table
Symbol table 'ST10'->'ST9':
End Symbol table
printing code segments (8):
code segment 'CS1'->'ST2'
end code segment
code segment 'CS2'->'ST3'
end code segment
code segment 'CS3'->'ST4'
end code segment
code segment 'CS4'->'ST5'
MOV reg1 0
MOV argc reg1
IFNOT argc lbl1
INSERT CS5
LABEL lbl1
MULTIPLY reg3 A argv
MOV A reg3
LABEL lbl2
IFNOT A lbl3
INSERT CS6
GOTO lbl2
LABEL lbl3
MOV reg8 0
RETURN reg8
end code segment
code segment 'CS5'->'ST8'
MOV reg2 1
RETURN reg2
end code segment
code segment 'CS6'->'ST9'
MOV reg4 1
DIVIDE reg5 A reg4
MOV A reg5
MOV reg6 1
MOV A reg6
IFNOT A lbl4
INSERT CS7
LABEL lbl4
end code segment
code segment 'CS7'->'ST10'
MOV reg7 1
RETURN reg7
end code segment
code segment 'CS8'->'ST7'
MOV reg9 1
ADD reg10 fluff reg9
MOV fluff reg10
end code segment

GOOD BYE
[Inferior 1 (process 2180) exited normally]
(gdb) (gdb) quit
