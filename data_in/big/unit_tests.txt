/// Unit test for LazyTongue 
/// Usage:
///   init_tests(); /// initialize the test suite
///   int res = run_tests(); /// check how it goes
///   if(res != CODE_OK) 
///		print("test %d, part %d failed\n", res, subtest_number);
///   end;

int tests[10];
int CODE_OK = -1;

int subtest_number = CODE_OK;
int subtest_expected = CODE_OK;
int subtest_got = CODE_OK;

void init_tests()
	tests[0] = test_1_funcptr;
	tests[1] = test_2_arithmetic;
end

int run_tests()
	int can_run_tests = test_1_funcptr();
	if(can_run_tests != CODE_OK) return -2; end
	
	int i = 0;
	while(tests[i])
		subtest_number = CODE_OK;
		int* func = tests[i];
		int res = func();
		if(res != CODE_OK)
			return i; 
		end
		i++;
	end
   return CODE_OK;
end

int buffs_equal(int* buff1, int* buff2, int size)
	subtest_number = CODE_OK;
	subtest_expected = CODE_OK;
	subtest_got = CODE_OK;
	for(int i = 0; i < size; i++)
    	if(buff1[i] != buff2[i]) 
			subtest_number = i;
			subtest_expected = buff2[i];
			subtest_got = buff1[i];
			return i; 
		end
  	end
  return CODE_OK;
end

/// --- function pointers - this verifies that we are able to run tests at all...
int test_1_var = 0;
int test_1_helper() // hello()
	test_1_var = 1;
	return 10;
end

int test_1_funcptr()
	int res[7]; int ref[7];
	res[0] = test_1_helper;		ref[0] = 461; /// hardcoded function pointer may drift if we change above code
	res[1] = &test_1_helper;	ref[1] = 461;
	res[2] = *test_1_helper;	ref[2] = 461;
	int *p1 = test_1_helper;
	int p2 = test_1_helper;
	res[3] = p1;				ref[3] = 461;
	res[4] = p2;				ref[4] = 461; /// ps: missing semicolon here is reported as "unexpected <next token>"
	int res = test_1_helper();
	res[5] = res;				ref[5] = 10;
	res[6] = test_1_var;		ref[6] = 1;  ///ps: missing semicolon here is reported as "no source text"
	
	return buffs_equal(res, ref, 7);
end

int test_2_arithmetic()
	int x = 10;
	int y = 20;
	int res[8]; int ref[8];
	res[0] = x+y; ref[0] = 30;
	res[1] = x-y; ref[1] = -10;
	res[2] = x*y; ref[2] = 200;
	res[3] = x/y; ref[3] = 0;
	res[4] = y/x; ref[4] = 2;
	res[5] = x>y; ref[5] = 0;
	res[6] = x<y; ref[6] = 1;
	res[7] = x == y; ref[7] = 0;
	
	return buffs_equal(res, ref, 8);
end



