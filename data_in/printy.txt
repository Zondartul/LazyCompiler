//hello, am printy

char *lorem_ipsum(int I)
   int sw = I % 10;
   if(sw == 0) return "Lorem ipsum dolor sit amet, "; end
   if(sw == 1) return "consectetur adipiscing elit. "; end
   if(sw == 2) return "Nam auctor lorem in massa tempor bibendum. "; end
   if(sw == 3) return "Nulla in metus in nunc ornare "; end
   if(sw == 4) return "porta ullamcorper non enim. "; end
   if(sw == 5) return "Donec tincidunt magna "; end
   if(sw == 6) return "non tellus blandit faucibus. "; end
   if(sw == 7) return "Nullam ac sem vitae lectus gravida vulputate. "; end
   if(sw == 8) return "Quisque quis lacinia risus, "; end
   if(sw == 9) return "non rutrum turpis. "; end
   return "(oops)";
end

//returns the (floored) log10 of a number, i.e. number of digits in floor(num).
//assumes num is positive
int ilog10(float num)
	for(int i = 0; i < 10; i++)
		if(num < 10) return i; end
		num = num / 10;
	end
end

//returns 10^num
int ipow10(int num)
	int x = 1;
	for(int i = 0; i < num; i++)
		x = x*10;
	end
	return x;
end

int numDigits(float num) return ilog10(num)+1; end

int getNdigit(float num, int dig)
	//1. remove the lower parts
	num = num / ipow10(dig);
	//2. get the lowest remaining digit
	num = num % 10;
	return num;
end

int floor(float num)
	int res = 0;
	int n = numDigits(num);
	for(int i = 0; i < n; i++)
		int d = getNdigit(num, i);
		res = res + d * ipow10(i);
	end
	return res;
end

int floorPrec(float num, float prec)
	//printf("floorPrec(%d):\n", num);
	int k = ipow10(prec); 	//printf(" ipow10(%d) = %d\n", prec, k);
	num = num * k; 			//printf(" num*k = %d\n", num);
	num = floor(num);		//printf(" floor(num) = %d\n", num);
	num = num / k;			//printf(" num/k = %d\n", num);
	return num;
end

float frac(float num)
	int isNeg = (num < 0);
	if(isNeg) num = -num; end
	float f = num - floor(num);
	if(isNeg) f = -f; end
	return f;
end

int strlen(char *str)
	int i = 0;
	while(*str++) i++; end
	return i;
end

void string_reverse(char *str)
	int len = strlen(str);
	for(int i = 0; i < len/2; i++)
		int opposite = len-1-i;
		char d = str[i];
		str[i] = str[opposite];
		str[opposite] = d;
	end	
end

void int2str(float num, char *buff)
	char *buffInit = buff;
//	if(num == 0)
//		buff[0] = '0';//*buff++ = '0';
//		buff++;
//		buff[0] = 1;//*buff = 0;
//	end
	int isNeg = 0;
	if(num < 0) isNeg = 1; num = -num; end
	int End = 0;
	while(End==0)
		int d = num % 10;	
		buff[0] = '0'+d;
		buff++;
		num = num / 10;
		
		if(num<1) //if(num == 0)
			if(isNeg) buff[0] = '-'; buff++; end
			buff[0] = 0;
			End = 1;
		end
	end
	string_reverse(buffInit);
end


void memmove(char *dest, char *src, int size)
	if(dest > src)
		//print(".moveback.");
		for(int i = size-1; i > -1; i--)
			dest[i] = src[i];
		end
	end
	if(dest < src)
		for(int i = 0; i < size; i++)
			dest[i] = src[i];
		end
	end
end

void strmove(char *dest, char *src)
	int len = strlen(src);
	memmove(dest, src, len+1); //includes terminating zero
end

//if the string is shorter than padlen, pads in with padchar
void strPadBegin(char *str, int padlen, char padchar)
	int len = strlen(str);
	if(len < padlen)
		int diff = padlen - len;
		strmove(str+diff, str);
		for(int i = 0; i < diff; i++)
			str[i] = padchar;
		end
	end
end

void strPadEnd(char *str, int padlen, char padchar)
	int len = strlen(str);
	if(len < padlen)
		int diff = padlen - len;
		for(int i = 0; i < diff; i++)
			str[len+i] = padchar;
		end
		str[padlen] = 0;
	end
end

void float2str(float num, int prec, char *buff)
	char *buffInit = buff;
	int isNeg = (num < 0);
	if(isNeg) num = -num; end
	int num_fl = floor(num);
	float num_fr = frac(num);
	float num_frpr = floorPrec(num_fr, prec);
	//printf("float2str(%d, %d):\n",num, prec);
	//printf("  num_fl = %d\n", num_fl);
	//printf("  num_fr*1000 = %d\n", num_fr*1000);
	//printf("  num_frpr*1000 = %d\n", num_frpr*1000);
	//if(isNeg) *buff++ = '-'; end
	if(isNeg) buff[0] = '-'; buff++; end
	int2str(num_fl, buff);
	buff = buff + strlen(buff);
	//if(num_fr)
		//*buff++ = '.';
		buff[0] = '.';
		buff++;
		int k = ipow10(prec);
		float num_final = floor(num_frpr*k);
		//printf("  num_final = %d\n", num_final);
		int2str(num_final, buff);
		strPadBegin(buff, prec, '0');
	//end
end



int sprintf(char *buff, char *fmt, int *parg)
	int printed = 0;
	while(*fmt)
		char c = *fmt;
		if(c == '%')
			fmt++;
			char c2 = *fmt;
			fmt++;
			if(c2 == 'd') int2str(*parg, buff); parg++; end
			if(c2 == 'f') float2str(*parg, 4, buff); parg++; end
			if(c2 == 's') strmove(buff, *parg); parg++; end
			if(c2 == 'c') buff[0] = *parg; parg++; buff[1] = 0; end
			if(c2 == '%') buff[0] = '%'; buff[1] = 0; end
			int inc = strlen(buff);
			printed = printed + inc;
			buff = buff + inc;
		end
		if(c != '%')
			if(c == '\')
				fmt++;
				char c2 = *fmt;
				fmt++;
				if(c2 == 'n') buff[0] = charcode_NL; buff[1] = 0; end
				if(c2 == 'r') buff[0] = charcode_CR; buff[1] = 0; end
				if(c2 == 'f') buff[0] = charcode_FILL; buff[1] = 0; end
				if(c2 == 'b') buff[0] = charcode_BACK; buff[1] = 0; end
				if(c2 == 'e') buff[0] = charcode_BELL; buff[1] = 0; end
				if(c2 == '\') buff[0] = '\'; buff[1] = 0; end
				int inc = strlen(buff);
				printed = printed + inc;
				buff = buff+inc;
			end
			if(c != '\')
				buff[0] = c;
				buff[1] = 0;
				printed++;
				buff++;
				fmt++;
			end
		end
	end
	return printed;
end

int printf(char *fmt, float args)
	int printed = 0;
	char buff[80];
	int *parg = &args;
	printed = sprintf(buff, fmt, parg);
	Prints(buff, 999);
	return printed;
end















