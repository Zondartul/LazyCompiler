%{
	
%}
%code requires {
  //#define YYLTYPE YYLTYPE
  #include "globals.h"
  #include "types/ast_node.h"
  
	//ast_node.h not fully included yet due to shenanigans
	typedef struct ast_node ast_node;
	
	extern ast_node *finalNode;
	void /*int*/ yyerror(const char *s);
}
%code provides{
char *posToString(YYLTYPE pos);
char *get_source_text2(YYLTYPE pos);
}	
%code {
	#include "globals.h"
  #include "AST.h"
  #include "semantic.h"
  #include "codegen.h"
	#include "vector2.h"
	#include "types/ast_node.h"

	ast_node *finalNode;

	//		B = B C | C
	//beceomes
	//		B = C C C C C
	void ast_unroll_lists_helper(ast_node *N2){
		//ast_node *N2 = ast_get_node(nodeID2);
		if(!N2->children.size){return;}
		ast_node *N3 = ast_get_child(N2,0);
		if(N2->token.type != N3->token.type){return;}
		ast_unroll_lists_helper(ast_get_child(N2, 0));
		m(N2->children,erase,0);
		int i;
		for(i = 0; i < N3->children.size; i++){
			//m(N2->children,push_back,ast_get_child_id(N3,i));
			m(N2->children,push_back,ast_get_child(N3,i));
		}
	}
	//turns left-recursive lists into non-recursive ones
	//so	A = B | empty
	//		B = B C | C
	//becomes	A = C C C C C C | empty
	
	void ast_unroll_lists(ast_node *N1){
		//ast_node *N1 = ast_get_node(nodeID);
		printf("unroll [%s] ",N1->token.type);
		if(!N1->children.size){return;}
		ast_node *N2 = ast_get_child(N1, 0);
		if(!N2->children.size){return;}
		//ast_unroll_lists_helper(ast_get_child_id(N1, 0));
		ast_unroll_lists_helper(ast_get_child(N1,0));
		m(N1->children,erase,0);
		int i;
		for(i = 0; i < N2->children.size; i++){
			//m(N1->children,push_front,ast_get_child_id(N2,i));
			m(N1->children,push_front,ast_get_child(N2,i));
		}
		printf(" unroll done\n");
	}
	
	void fix_decl_assign(ast_node *N1){
		//return;
		//struct ast_node *N1 = ast_get_node(nodeID);
		//int node_expr = *(int*)vector_get_reference(&N1->children,1);
		ast_node *node_expr = m(N1->children,pop_back);
		//vector_pop_back(&N1->children);
		//int node_ID = make_node((struct ast_token){"expr_id",0,N1->token.value,nullPos()},0);
		ast_node *node_ID = ast_node_new(ast_token_here("expr_id",0,N1->token.value,nullPos()),v2pan_here());
		//int N3 = make_node((struct ast_token){"expr_=",0,0,nullPos()},2,node_ID,node_expr);
		ast_node *N3 = ast_node_new(ast_token_here("expr_=",0,0,nullPos()),
									vector2_ptr_ast_node_here_from_list(2, node_ID, node_expr));
		//vector_set(&N1->children,1,&N3);
		m(N1->children,push_back,N3);
	}	
	
	int checkValidLoc(YYLTYPE loc, const char *name, int num){
		/*
		int null;
		int first_line;
		int first_column;
		int last_line;
		int last_column;
		int start;
		int end;
		char *filename;
		*/
		int valid = 1;
		if(loc.null){printf("checkValidLoc: loc [%s %d] is null\n",name,num); valid = 0;}
		else{
			if(loc.first_line > loc.last_line){printf("checkValidLoc: loc [%s %d] has first_line %d > last_line %d\n",name,num,loc.first_line,loc.last_line); valid = 0;}
			if(loc.first_line == loc.last_line){
				if(loc.first_column > loc.last_column){
					printf("checkValidLoc: loc [%s %d] has first_col %d > last_col %d on same line\n",name,num,loc.first_column,loc.last_column);
					valid = 0;
				}
			}
			if(loc.start > loc.end){printf("checkValidLoc: loc [%s %d] has start %d > end %d\n",name,num,loc.start,loc.end);valid = 0;}
			if(!loc.filename){printf("checkValidLoc: loc [%s %d] has no filename\n",name,num); valid = 0;}
		}
		return valid;
	}
	
	void printParsed(ast_node *node){
		printf("\n\n|parsed node [%s]-----\n", node->token.type);
		int valid = checkValidLoc(node->token.pos,"node",0);
		printf("|node loc check: %d\n",valid);
		printf("|node has %d children\n", node->children.size);
		for(int I = 0; I < node->children.size; I++){
			ast_node *N = ast_get_child(node,I);
			printf("|-child %d/%d: [%s]\n", I, node->children.size,N->token.type);
			int valid2 = checkValidLoc(N->token.pos,"child",I);
			printf("|-child loc valid: %d\n",valid2);
		}
		if(!(node->token.pos.null) && (node->token.pos.filename)){
			printf("|node sourcecode: [%s]\n",get_source_text2(node->token.pos));
		}else{
			printf("|no source\n");
		}
		printf(    "|end node    [%s]-----\n\n",node->token.type);
	}
	/* //collects all the stars and appends them to the node
	ast_unroll_stars_helper(int nodeID){
		struct ast_node *N1 = ast_get_node(nodeID);
		if(N1->children.size){
			
		}
	}
	ast_unroll_stars(int nodeID){
		struct ast_node *N1 = ast_get_node(nodeID);
		printf("unroll [%s] ",N1->token.type);
		ast_unroll_stars_helper(ast_get_child_id(N1,0));
		printf(" unroll done\n");
	} */
	# define YYLLOC_DEFAULT(Current, Rhs, N)				\
    do{		\
	 printf("YYLOC_DEFAULT(%d)\n",N);		\
    if(N) /*if (YYID (N))*/							\
	{								\
								\
		(Current).null = 1;	\
		(Current).first_line   = 0;\
		(Current).first_column = 0;\
		(Current).last_line    = 0;\
		(Current).last_column  = 0;\
		(Current).start        = 0;\
		(Current).end          = 0;\
		(Current).filename = 0;\
		int i = 0;	\
		int hasFirst = 0;	\
		for(i = 1; i <= N; i++){	\
			printf("RHS(%d).null=%d\n",i,YYRHSLOC(Rhs,i).null);	\
			/*checkValidLoc(YYRHSLOC(Rhs,i),"Rhs",i);*/ \
			if(!YYRHSLOC(Rhs,i).null){	\
				(Current).null = 0;	\
				if(!hasFirst){	\
					hasFirst = 1;	\
					(Current).first_line = YYRHSLOC(Rhs,i).first_line;	\
					(Current).first_column = YYRHSLOC(Rhs,i).first_column;	\
					(Current).start = YYRHSLOC(Rhs,i).start;	\
					(Current).filename = YYRHSLOC(Rhs,i).filename;\
				}	\
				(Current).last_line = YYRHSLOC(Rhs,i).last_line;	\
				(Current).last_column = YYRHSLOC(Rhs,i).last_column;	\
				(Current).end = YYRHSLOC(Rhs,i).end;	\
			}	\
		}	\
		/*checkValidLoc((Current), "LHS",0);*/ \
		printf("LHS.null=%d\n",(Current).null);\
	}								\
      else	/* this is what happens when we have an empty production */ \
	{								\
	  (Current).null = 1;	\
	  (Current).first_line   = 0;\
	  (Current).first_column = 0;\
	  (Current).last_line    = 0;\
	  (Current).last_column  = 0;\
	  (Current).start        = 0;\
	  (Current).end          = 0;\
	}}								\
    while(0)/*while (YYID (0))*/
//	    YYRHSLOC (Rhs, 0).last_column;	
//
/*

	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
	  (Current).start        = YYRHSLOC (Rhs, 1).start;			\
  (Current).first_line   = (Current).last_line   =		\
	    YYRHSLOC (Rhs, 0).last_line;				\
	  (Current).start = (Current).end = (Current).first_column = (Current).last_column =		\
	    YYRHSLOC (Rhs, 0).end;				\
	  (Current).filename = YYRHSLOC (Rhs, 0).filename;	\
	  */
}
%code {
	
	extern FILE *yyin;
	FILE *yyin2;

	int main(int argc, char **argv); //moved to main.c
	/* /// moved to semantic/yylloc.c
	void printPos(YYLTYPE pos){
		printf("null: %d\n",pos.null);
		printf("first_line: %d\n",pos.first_line);
		printf("first_column: %d\n",pos.first_column);
		printf("last_line: %d\n", pos.last_line);
		printf("last_column: %d\n", pos.last_column);
		printf("start: %d\n", pos.start);
		printf("end: %d\n", pos.end);
		printf("filename: [%s]\n",pos.filename);
	}


	void printPosErr(YYLTYPE pos){
		fprintf(stderr,"null: %d\n",pos.null);
		fprintf(stderr,"first_line: %d\n",pos.first_line);
		fprintf(stderr,"first_column: %d\n",pos.first_column);
		fprintf(stderr,"last_line: %d\n", pos.last_line);
		fprintf(stderr,"last_column: %d\n", pos.last_column);
		fprintf(stderr,"start: %d\n", pos.start);
		fprintf(stderr,"end: %d\n", pos.end);
		fprintf(stderr,"filename: [%s]\n",pos.filename);
	}
	*/

#define KNRM  "\x1B[0m"
#define KRED  "\x1B[31m"

///  from https://www.gnu.org/software/bison/manual/html_node/Error-Reporting-Function.html
/// The variable yynerrs contains the number of syntax errors reported so far. Normally this variable is global; 
/// but if you request a pure parser (see A Pure (Reentrant) Parser) then it is a local variable which only the actions can access.
	
	extern YYLTYPE prev_yylloc[3];

	void /*int*/ yyerror(const char *s)
	{	
		printf("\nyyerror(%s)!\n", s);
		int x1 = yylloc.first_column;
		int y1 = yylloc.first_line;
		int x2 = yylloc.last_column;
		//int y2 = yylloc.last_line;
		const char *f = yylloc.filename;
		int length = x2-x1;
		if(length == 1){length = 0;}
		point_out_error(y1,x1,f,s,length);
		fflush(stdout);
		
		//error("syntax error. yytext: [%s]\n",(char*)yylval);
		//error("[PARSE] Syntax error: %s\n", s);
		fprintf(stderr, "%s[PARSE] %s\n%s", KRED, s, KNRM);
		//exit(1);
		//return 1;
	}

	char *posToString(YYLTYPE pos){
		int start = pos.first_column;
		int end = pos.last_column;
		int len = end-start;
		char *buff = malloc(sizeof(char)*len);
		fseek(yyin2, start, SEEK_SET);
		fgets(buff, len, yyin2);
		return buff;
	}

	ast_node *production(const char* name, int prod_id, const char* value, YYLTYPE pos, ast_node *ch1, ast_node *ch2, ast_node *ch3, ast_node *ch4){
		ast_node *res = ast_node_new(
				ast_token_here(name,prod_id,value,pos),
				ch1? ch2? ch3? ch4?
				 vector2_ptr_ast_node_here_from_list(4, ch1, ch2, ch3, ch4)
				:vector2_ptr_ast_node_here_from_list(3, ch1, ch2, ch3)
				:vector2_ptr_ast_node_here_from_list(2, ch1, ch2)
				:vector2_ptr_ast_node_here_from_list(1, ch1)		
				:vector2_ptr_ast_node_here_from_list(0)			
			);
		printParsed(res);
	}

	ast_node *error_production(const char* msg, YYLTYPE pos){
		yylloc = prev_yylloc[3]; 
		yyerror("Syntax error: expected semicolon ';'"); 
		return ast_node_new(ast_token_here("error",0,NULL,pos),vector2_ptr_ast_node_here_from_list(0));
	}
	#define STR_ERR_SEMICOLON "Syntax error: expected semicolon ';'"
	#define STR_ERR_END "Syntax error: expected 'end'"

}

%token RETURN CLASS ID TYPE END IF ELSE ELSEIF WHILE FOR INTEGER INTEGERX INTEGERB FLOATING CHARACTER STRING EQUAL NOTEQUAL INC DEC
/*%glr-parser*/
%debug
%error-verbose
%left '='
%left '|' '&'
%left EQUAL NOTEQUAL '<' '>'
%left '+' '-'
%left '^' '/' '*'
//%left '.' 
%precedence '[' //']'
%precedence '(' //')' 
%precedence PREDEREF PREREF '!'
%precedence PREINC PREDEC 
%precedence PRENEG
%left '.' 
//%precedence POSTINC POSTDEC
%%

program :	decl_stmt_list	
							{	
								YYLTYPE pos = @$;
								ast_node *child1 = $1;
								finalNode = ast_node_new(
									ast_token_here("program",0,NULL,pos),
									vector2_ptr_ast_node_here_from_list
									(1, child1)
								);
								printParsed(finalNode);
							}		
		;

stmt	:	imp_stmt		
							{
								ast_node **res = &($$);
								*res = ast_node_new(
									ast_token_here("stmt",0,NULL,@$),
									vector2_ptr_ast_node_here_from_list
									(1, $1)
								);
								printParsed(*res);
							}
		|	decl_stmt		
							{

								//$$ = ast_node_new(
								//	ast_token_here("stmt",1,NULL,@$),
								//	vector2_ptr_ast_node_here_from_list
								//	(1, $1)
								//);
								printParsed($$);
								$$ = production("stmt",1,NULL,@$,$1,0,0,0);
							}
		;
		
stmt_list	: stmt_list_ne		
								{
									//$$ = ast_node_new(
									//	ast_token_here("stmt_list",0,NULL,@$),
									//	vector2_ptr_ast_node_here_from_list
									//	(1, $1)
									//);
									//printParsed($$);
									$$ = production("stmt_list",0,NULL,@$,$1,0,0,0);
									ast_unroll_lists($$);
								}
			|					
								{
									//YYLTYPE *pos = &(@$);
									//pos->null = 1;
									@$.null = 1;

									//$$ = ast_node_new(
									//	ast_token_here("stmt_list",1,"<empty>",nullPos()),//@$),
									//	vector2_ptr_ast_node_here_from_list
									//	(0)
									//);
									//printParsed($$);
									$$ = production("stmt_list",1,"<empty>",nullPos(),0,0,0,0);

								} %empty
			;
		
stmt_list_ne	: stmt_list_ne stmt	
									{
										// $$ = ast_node_new(
										// 	ast_token_here("stmt_list_ne",0,NULL,@$),
										// 	vector2_ptr_ast_node_here_from_list
										// 	(2, $1, $2)
										// );
										// printParsed($$);
										$$ = production("stmt_list_ne",0,NULL,@$,$1,$2,0,0);
									}
				| stmt				
									{
										// $$ = ast_node_new(
										// 	ast_token_here("stmt_list_ne",1,NULL,@$),
										// 	vector2_ptr_ast_node_here_from_list
										// 	(1, $1)
										// );
										// printParsed($$);
										$$ = production("stmt_list_ne",1,NULL,@$,$1,0,0,0);
									}
				;
		
decl_stmt	:	decl_stmt_end {$$ = $1;}
			|	decl_stmt_smc {$$ = $1;}
			;
			
decl_stmt_end:	/// declarative statement, that ends with 'end'
			class_def		
								{
									// $$ = ast_node_new(
									// 	ast_token_here("decl_stmt",0,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $1)
									// );
									// printParsed($$);
									$$ = production("decl_stmt",0,NULL,@$,$1,0,0,0);
								}
			|	func_def		
								{
									// $$ = ast_node_new(
									// 	ast_token_here("decl_stmt",1,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $1)
									// );
									// printParsed($$);
									$$ = production("decl_stmt",1,NULL,@$,$1,0,0,0);
								}
			|	error 			{   $$ = error_production(STR_ERR_END, @$);}
			;

decl_stmt_smc:	var_decl ';' 	{
									// $$ = ast_node_new(
									// 	ast_token_here("decl_stmt",2,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $1)
									// );
									// printParsed($$);
									$$ = production("decl_stmt",2,NULL,@$,$1,0,0,0);
								}
			|	error 			{   $$ = error_production(STR_ERR_SEMICOLON, @$);}
			;	
			
decl_stmt_list	:	decl_stmt_list_ne	
								{
									// $$ = ast_node_new(
									// 	ast_token_here("decl_stmt_list",0,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $1)
									// );
									// printParsed($$);
									$$ = production("decl_stmt_list",0,NULL,@$,$1,0,0,0);
									ast_unroll_lists($$);
								}
				|						
								{
									//YYLTYPE *pos = &(@$);
									//pos->null = 1;
									@$.null =  1;

									// $$ = ast_node_new(
									// 	ast_token_here("decl_stmt_list",1,"<empty>",nullPos()),//@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(0)
									// );
									// printParsed($$);
									$$ = production("decl_stmt_list",1,"<empty>",nullPos(),0,0,0,0);
								} %empty
				;

decl_stmt_list_ne	: decl_stmt_list_ne decl_stmt  
								{
									// $$ = ast_node_new(
									// 	ast_token_here("decl_stmt_list_ne",0,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(2, $1, $2)
									// );
									// printParsed($$);
									$$ = production("decl_stmt_list_ne",0,NULL,@$,$1,$2,0,0);
								}
					| decl_stmt						
								{
									// $$ = ast_node_new(
									// 	ast_token_here("decl_stmt_list_ne",1,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $1)
									// );
									// printParsed($$);
									$$ = production("decl_stmt_list_ne",1,NULL,@$,$1,0,0,0);
								}
					;
//synchronize :   ';' | END ; // list of ways to get back to parsing after an error production
//semicolon_or_error : ';' | error synchronize   {   yyerror("Syntax error: expected semicolon ';'"); $$ = ast_node_new(ast_token_here("error",0,NULL,@$),vector2_ptr_ast_node_here_from_list(0));} ;  				
imp_stmt	:	imp_stmt_smc	{ $$ = $1;}
			|	imp_stmt_end	{ $$ = $1;}
			;
imp_stmt_end:	/// imperative statement, that ends with 'end'
				if_block					
								{
									// $$ = ast_node_new(
									// 	ast_token_here("imp_stmt",0,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $1)
									// );
									// printParsed($$);
									$$ = production("imp_stmt",0,NULL,@$,$1,0,0,0);
								}
			|	while_loop					
								{
									// $$ = ast_node_new(
									// 	ast_token_here("imp_stmt",1,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $1)
									// );
									// printParsed($$);
									$$ = production("imp_stmt",1,NULL,@$,$1,0,0,0);
								}
			|	for_loop					
								{
									// $$ = ast_node_new(
									// 	ast_token_here("imp_stmt",5,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $1)
									// );
									// printParsed($$);
									$$ = production("imp_stmt",5,NULL,@$,$1,0,0,0);
								}
								
			|	error 			{   $$ = error_production(STR_ERR_END, @$);}
			;

imp_stmt_smc:	/// imperative statement, that ends in semicolon ';'
				expr ';'					
								{
									// $$ = ast_node_new(
									// 	ast_token_here("imp_stmt",2,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $1)
									// );
									// printParsed($$);
									$$ = production("imp_stmt",2,NULL,@$,$1,0,0,0);
								}
			|	RETURN ';'					
								{
									// $$ = ast_node_new(
									// 	ast_token_here("imp_stmt",3,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(0)
									// );
									// printParsed($$);
									$$ = production("imp_stmt",3,NULL,@$,0,0,0,0);
								}
			|	RETURN expr ';'				
								{
									// $$ = ast_node_new(
									// 	ast_token_here("imp_stmt",4,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $2)
									// );
									// printParsed($$);
									$$ = production("imp_stmt",5,NULL,@$,$2,0,0,0);
								}
			|	error 			{   $$ = error_production(STR_ERR_SEMICOLON, @$);}
			;
			
class_def	:	CLASS ID decl_stmt_list END	
								{
									const char *id_str = $2->token.value;
									printf("CLASS_DEF ID = [%s]\n",id_str);
									// $$ = ast_node_new(
									// 	ast_token_here("class_def",0,id_str, @$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(2, $2, $3)
									// );
									// printParsed($$);
									$$ = production("class_def",0,id_str,@$,$2,$3,0,0);
								}

STAR		:   '*'					
								{
									// $$ = ast_node_new(
									// 	ast_token_here("stars",0,"*",@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(0)
									// );
									// printParsed($$);
									$$ = production("stars",0,"*",@$,0,0,0,0);
								}
			;

ptr_stars	:	ptr_stars_ne		
								{
									// $$ = ast_node_new(
									// 	ast_token_here("ptr_stars",0,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $1)
									// );
									// printParsed($$);
									$$ = production("ptr_stars",0,NULL,@$,$1,0,0,0);
									ast_unroll_lists($$);
								}
			|						
								{
									// $$ = ast_node_new(
									// 	ast_token_here("ptr_stars",1,"<empty>",nullPos()),//@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(0)
									// );
									// printParsed($$);
									$$ = production("ptr_stars",1,"<empty>",nullPos(),0,0,0,0);
								}	%empty
			;

ptr_stars_ne:	ptr_stars_ne STAR	
								{
									// $$ = ast_node_new(
									// 	ast_token_here("ptr_stars_ne",0,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(2, $1, $2)
									// );
									// printParsed($$);
									$$ = production("ptr_stars_ne",0,NULL,@$,$1,$2,0,0);
								}
			|	STAR				
								{
									// $$ = ast_node_new(
									// 	ast_token_here("ptr_stars_ne",1,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $1)
									// );
									// printParsed($$);
									$$ = production("ptr_stars_ne",1,NULL,@$,$1,0,0,0);
								}
			;

typename	:	TYPE	 ptr_stars	
								{
									const char *type_str = $1->token.value;
									// $$ = ast_node_new(
									// 	ast_token_here("typename",0,type_str, @$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(2, $1, $2)
									// );
									// printParsed($$);
									$$ = production("typename",0,type_str,@$,$1,$2,0,0);
								}
			|	CLASS ID ptr_stars	
								{
									const char *type_str = $2->token.value;
									// $$ = ast_node_new(
									// 	ast_token_here("typename",1,type_str, @$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(2, $2, $3)
									// );
									// printParsed($$);
									$$ = production("typename",1,type_str,@$,$2,$3,0,0);
								}
			;

func_def	:	typename ID '('	var_decl_list ')' stmt_list END	
								{
									const char *id_str = $2->token.value;
									printf("FUNC_DEF ID = [%s]\n", id_str);
									// $$ = ast_node_new(
									// 	ast_token_here("func_def", 0, id_str, @$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(4, $1, $2, $4, $6)
									// );
									// printParsed($$);
									$$ = production("func_def",0,id_str,@$,$1,$2,$4,$6); // rare one that uses 4 args
								}

var_decl	:	typename ID						
								{
									const char *id_str = $2->token.value;
									// $$ = ast_node_new(
									// 	ast_token_here("var_decl",0,id_str, @$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(2, $1, $2)
									// );
									// printParsed($$);
									$$ = production("var_decl",0,id_str,@$,$1,$2,0,0);
								}
			|	typename ID '[' expr ']'		
								{
									const char *id_str = $2->token.value;
									// $$ = ast_node_new(
									// 	ast_token_here("var_decl",1,id_str, @$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(3, $1, $2, $4)
									// );
									// printParsed($$);
									$$ = production("var_decl",1,id_str,@$,$1,$2,$4,0);
								}
			|	typename ID '=' expr			
								{
									const char *id_str = $2->token.value;
									// $$ = ast_node_new(
									// 	ast_token_here("var_decl_assign",0,id_str,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(3, $1, $2, $4)
									// );
									// printParsed($$);
									$$ = production("var_decl_assign",0,id_str,@$,$1,$2,$4,0);
								}
			|	typename ID '(' expr_list ')'
								{
									const char *id_str = $2->token.value;
									// $$ = ast_node_new(
									// 	ast_token_here("var_decl_constructor",0,id_str,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(3, $1, $2, $4)
									// );
									// printParsed($$);
									$$ = production("var_decl_constructor",0,id_str,@$,$1,$2,$4,0);
								}
			;

var_decl_list	:	var_decl_list_ne			
								{
									// $$ = ast_node_new(
									// 	ast_token_here("var_decl_list",0,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $1)
									// );
									// printParsed($$);
									$$ = production("var_decl_list",0,NULL,@$,$1,0,0,0);
									ast_unroll_lists($$);
								}
				|								
								{
									// $$ = ast_node_new(
									// 	ast_token_here("var_decl_list",1,"<empty>",nullPos()),//@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(0)
									// );
									// printParsed($$);
									$$ = production ("var_decl_list",1,"<empty>",nullPos(),0,0,0,0);
								} %empty //inform Bison/YACC that this rule was intentionally left empty
				;
				
var_decl_list_ne	:	var_decl_list_ne ',' var_decl	
								{
									// $$ = ast_node_new(
									// 	ast_token_here("var_decl_list_ne",0,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(2, $1, $3)
									// );
									// printParsed($$);
									$$ = production("var_decl_list_ne",0,NULL,@$,$1,$3,0,0);
								}
					|	var_decl						
								{
									// $$ = ast_node_new(
									// 	ast_token_here("var_decl_list_ne",1,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $1)
									// );
									// printParsed($$);
									$$ = production("var_decl_list_ne",1,NULL,@$,$1,0,0,0);
								}
					;
				
if_block	:	if_then END									
								{
									// $$ = ast_node_new(
									// 	ast_token_here("if_block",0,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $1)
									// );
									// printParsed($$);
									$$ = production("if_block",0,NULL,@$,$1,0,0,0);
								}
			|	if_then ELSE stmt_list END					
								{
									// $$ = ast_node_new(
									// 	ast_token_here("if_block",1,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(2, $1, $3)
									// );
									// printParsed($$);
									$$ = production("if_block",1,NULL,@$,$1,$3,0,0);
								}
			;

if_then		:	IF '(' expr ')' stmt_list	
								{
									// $$ = ast_node_new(
									// 	ast_token_here("if_then",0,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(2, $3, $5)
									// );
									// printParsed($$);
									$$ = production("if_then",0,NULL,@$,$3,$5,0,0);
								}
			|	if_then ELSEIF '(' expr ')' stmt_list
								{
									// $$ = ast_node_new(
									// 	ast_token_here("if_then",2,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(3, $1, $4, $6)
									// );
									// printParsed($$);
									$$ = production("if_then",2,NULL,@$,$1,$4,$6,0);
								}
			;
			
while_loop	:	WHILE '(' expr ')' stmt_list END	
								{
									// $$ = ast_node_new(
									// 	ast_token_here("while_loop",0,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(2, $3, $5)
									// );
									// printParsed($$);
									$$ = production("while_loop",0,NULL,@$,$3,$5,0,0);
								}
			;

for_loop	:	FOR '(' stmt expr ';' expr ')' stmt_list END	
								{
									// $$ = ast_node_new(
									// 	ast_token_here("for_loop",0,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(4, $3, $4, $6, $8)
									// );
									// printParsed($$);
									$$ = production("for_loop",0,NULL,@$,$3,$4,$6,$8); // another complex production with all 4 args
								}
			;
			
expr_list	:	expr_list_ne	
								{
									// $$ = ast_node_new(
									// 	ast_token_here("expr_list",0,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $1)
									// );
									// printParsed($$);
									$$ = production("expr_list",0,NULL,@$,$1,0,0,0);
									ast_unroll_lists($$);
								}
			|					
								{
									//YYLTYPE *pos = &(@$);
									//pos->null = 1;
									@$.null = 1;
									// $$ = ast_node_new(
									// 	ast_token_here("expr_list",1,"<empty>",nullPos()),//@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(0)
									// );	
									// printParsed($$);
									$$ = production("expr_list",1,"<empty>",nullPos(),0,0,0,0);
								} %empty
			;
			
expr_list_ne	: expr_list_ne ',' expr	
								{
									// $$ = ast_node_new(
									// 	ast_token_here("expr_list_ne",0,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(2, $1, $3)
									// );
									// printParsed($$);
									$$ = production("expr_list_ne",0,NULL,@$,$1,$3,0,0);
								}
				| expr					
								{
									// $$ = ast_node_new(
									// 	ast_token_here("expr_list_ne",1,NULL,@$),
									// 	vector2_ptr_ast_node_here_from_list
									// 	(1, $1)
									// );
									// printParsed($$);
									$$ = production("expr_list_ne",1,NULL,@$,$1,0,0,0);
								}
				;

expr	:	ID							{$$ = production("expr_id",0,$1->token.value,@$,yylval,0,0,0);}
//{$$ = ast_node_new(ast_token_here("expr_id",	0,$1->token.value,@$), vector2_ptr_ast_node_here_from_list(1, yylval)); printParsed($$);}
		|	INTEGER						{$$ = production("expr_const",0,$1->token.value,@$,yylval,0,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_const",	0,$1->token.value,@$), vector2_ptr_ast_node_here_from_list(1, yylval)); printParsed($$);}
		|	INTEGERX					{$$ = production("expr_const",1,$1->token.value,@$,yylval,0,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_const",	1,$1->token.value,@$), vector2_ptr_ast_node_here_from_list(1, yylval)); printParsed($$);}
		|	INTEGERB					{$$ = production("expr_const",2,$1->token.value,@$,yylval,0,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_const",	2,$1->token.value,@$), vector2_ptr_ast_node_here_from_list(1, yylval)); printParsed($$);}
		|	FLOATING					{$$ = production("expr_const",3,$1->token.value,@$,yylval,0,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_const",	3,$1->token.value,@$), vector2_ptr_ast_node_here_from_list(1, yylval)); printParsed($$);}
		|	CHARACTER					{$$ = production("expr_const",4,$1->token.value,@$,yylval,0,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_const",	4,$1->token.value,@$), vector2_ptr_ast_node_here_from_list(1, yylval)); printParsed($$);}
		|	STRING						{$$ = production("expr_const",5,$1->token.value,@$,yylval,0,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_const",	5,$1->token.value,@$), vector2_ptr_ast_node_here_from_list(1, yylval)); printParsed($$);}
		|	expr '[' expr ']'			{$$ = production("expr_index",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_index",	0,NULL,@$),	vector2_ptr_ast_node_here_from_list(2, $1,$3)); printParsed($$);}
		|	'(' expr ')'				{$$ = production("expr_subexpr",0,NULL,@$,$2,0,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_subexpr",0,NULL,@$),vector2_ptr_ast_node_here_from_list(1, $2)); printParsed($$);}
		|	'{' expr_list '}'			{$$ = production("expr_braced_list",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_braced_list",	0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $1, $3)); printParsed($$);}
		|	expr '(' expr_list ')'		{$$ = production("expr_call",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_call",	0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $1, $3)); printParsed($$);}
		|	expr '.' expr				{$$ = production("expr_.",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_.",		0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $1, $3)); printParsed($$);}
		|	expr '^' expr				{$$ = production("expr_^",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_^",		0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $1, $3)); printParsed($$);}
		|	expr '/' expr				{$$ = production("expr_/",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_/",		0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $1, $3)); printParsed($$);}
		|	expr '*' expr				{$$ = production("expr_*",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_*",		0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $1, $3)); printParsed($$);}
		|	expr '%' expr				{$$ = production("expr_%",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_%",		0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $1, $3)); printParsed($$);}
		|	expr '-' expr				{$$ = production("expr_-",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_-",		0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $1, $3)); printParsed($$);}
		|	expr '+' expr				{$$ = production("expr_+",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_+",		0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $1, $3)); printParsed($$);}
		|	'(' typename ')' expr		{$$ = production("expr_cast",0,NULL,@$,$2,$4,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_cast",	0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $2, $4)); printParsed($$);}
		|	'!' expr					{$$ = production("expr_not",0,NULL,@$,$2,0,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_not",	0,NULL,@$), vector2_ptr_ast_node_here_from_list(1, $2)); printParsed($$);}
		|	expr '&' expr				{$$ = production("expr_and",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_and",	0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $1, $3)); printParsed($$);}
		|	expr '|' expr				{$$ = production("expr_|",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_or",	0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $1, $3)); printParsed($$);}
		|	expr EQUAL expr				{$$ = production("expr_==",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_==",	0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $1, $3)); printParsed($$);}
		|	expr NOTEQUAL expr		  	{$$ = production("expr_!=",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_!=",	0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $1, $3)); printParsed($$);}
		|	expr '>' expr			 	{$$ = production("expr_>",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_>",		0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $1, $3)); printParsed($$);}
		|	expr '<' expr			 	{$$ = production("expr_<",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_<",		0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $1, $3)); printParsed($$);}
		|	expr '=' expr				{$$ = production("expr_=",0,NULL,@$,$1,$3,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_=",		0,NULL,@$), vector2_ptr_ast_node_here_from_list(2, $1, $3)); printParsed($$);}
		|	expr INC					{$$ = production("expr_++",0,NULL,@$,$1,0,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_++",	0,NULL,@$), vector2_ptr_ast_node_here_from_list(1, $1)); printParsed($$);}
		|	INC	expr    %prec PREINC	{$$ = production("expr_++",1,NULL,@$,$2,0,0,0);} // note: repaired from $1
		//{$$ = ast_node_new(ast_token_here("expr_++",	1,NULL,@$), vector2_ptr_ast_node_here_from_list(1, $1)); printParsed($$);}
		|	expr DEC					{$$ = production("expr_--",0,NULL,@$,$1,0,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_--",	0,NULL,@$), vector2_ptr_ast_node_here_from_list(1, $1)); printParsed($$);}
		|	DEC	expr    %prec PREDEC	{$$ = production("expr_--",1,NULL,@$,$2,0,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_--",	1,NULL,@$), vector2_ptr_ast_node_here_from_list(1, $2)); printParsed($$);}
		|	'-' expr 	%prec PRENEG	{$$ = production("expr_neg",0,NULL,@$,$2,0,0,0:)}
		//{$$ = ast_node_new(ast_token_here("expr_neg",	0,NULL,@$), vector2_ptr_ast_node_here_from_list(1, $2)); printParsed($$);}
		|	'*' expr	%prec PREDEREF	{$$ = production("expr_deref",0,NULL,@$,$2,0,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_deref",	0,NULL,@$), vector2_ptr_ast_node_here_from_list(1, $2)); printParsed($$);}
		|	'&' expr	%prec PREREF	{$$ = production("expr_ref",0,NULL,@$,$2,0,0,0);}
		//{$$ = ast_node_new(ast_token_here("expr_ref",	0,NULL,@$), vector2_ptr_ast_node_here_from_list(1, $2)); printParsed($$);}
		;

%%

