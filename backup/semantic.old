#include "globals.h"
#include "semantic.h"
#include "stdlib.h"
#include "string.h"
implementation_vector_of(ptr_symbol);
implementation_vector_of(ptr_symbol_table);
implementation_vector_of(ptr_code_segment);
implementation_vector_of(ptr_char);
implementation_vector_of(ptr_type_name);
implementation_vector_of(ptr_semantic_context_kind);
int semantic_decl;
struct symbol_table *currentSymbolTable;
ptr_symbol symbolThis;
vector2_ptr_symbol_table ST_stack;
vector2_ptr_symbol_table ST_list;
vector2_ptr_code_segment CS_stack;
vector2_ptr_code_segment CS_list;
vector2_ptr_char expr_stack;
vector2_ptr_type_name exprtype_stack;
// vector ST_stack;
// vector CS_stack;
// vector expr_stack;
//what is the context of our parsing
enum semantic_context_kind semantic_context;
vector2_ptr_semantic_context_kind semantic_context_stack;

void push_semantic_context(){
	ptr_semantic_context_kind sc = (enum semantic_context_kind*)malloc(sizeof(enum semantic_context_kind));
	*sc = semantic_context;
	m(semantic_context_stack,push_back,sc);
}

void pop_semantic_context(){
	ptr_semantic_context_kind sc = m(semantic_context_stack,pop_back);
	semantic_context = *sc;
	free(sc);
}

//const char *exprResult;
int semantic_analyze_pad = 0;
const char *semantic_this;
int semantic_flatten = 1;
void semantic_analyze(struct ast_node *node){
	int i;
	for(i = 0; i < semantic_analyze_pad; i++){printf(" ");}
	semantic_analyze_pad++;
	printf("semantic got %s,",node->token.type);
	if(node->token.value){printf(" \"%s\",",node->token.value);}
	printf(" prod %d,",node->token.production);
	printf(" @ %d-%d,",node->token.pos.start,node->token.pos.end);
	if(semantic_decl){printf(" declarative pass\n");}
	else{printf(" imperative pass\n");}
	printf("-----------------\n%s\n-----------------\n",
		get_source_text(node->token.pos.start,node->token.pos.end));
	if(!strcmp(node->token.type, "program")){
		//printf("got program\n");
		analyze_scope(ast_get_child(node,0),0,0,0,0);
		// new_symbol_table();
		// push_symbol_table();
		// semantic_decl = 1;
		// semantic_analyze(ast_get_child(node, 0));
		// semantic_decl = 0;
		// semantic_analyze(ast_get_child(node, 0));
		// pop_symbol_table();
		semantic_finalize();
		printf("semantic: done\n");
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "decl_stmt_list")){
		//printf("got decl_stmt_list\n");
		//semantic_decl = 1;
		for(i = 0; i < node->children.size; i++){
			semantic_analyze(ast_get_child(node, i));
		}
		// semantic_decl = 0;
		// for(i = 0; i < node->children.size; i++){
			// semantic_analyze(ast_get_child(node, i));
		// }
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "decl_stmt")){
		//if(!semantic_decl){return;}
		//printf("got decl_stmt\n");
		semantic_analyze(ast_get_child(node,0));
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "func_def")){
		//if(!semantic_decl){return;}
		//printf("got func_def\n");
		struct type_name *T = semantic_get_type(ast_get_child(node,0)->token.value);
		const char *name = node->token.value;
		if(semantic_decl){
			struct symbol *S = new_symbol();
			S->type = SYMBOL_FUNCTION;
			S->storage = STORE_CODE;
			S->username = name;
			if(semantic_flatten){
				S->IR_name = IR_next_name(name);
			}else{
				S->IR_name = name;
			}
			//get arguments
			//struct symbol_table *ST = new_symbol_table();
			S->symfunction.returntype = T;
			push_symbol_table();
			new_symbol_table();
			S->symfunction.scope = currentSymbolTable;
			//m(ST_stack,push_back,currentSymbolTable);
			if(semantic_context == SEMANTIC_MEMBER){
				//add param: this;
				struct type_name *T = semantic_get_type(symbolThis->username);
				T->pointerlevel = 1;
				char *name = "this";
				struct symbol *S;
				S = new_symbol();
				S->username = name;
				if(semantic_flatten){
					S->IR_name = IR_next_name(name);
				}else{
					S->IR_name = name;
				}
				S->type = SYMBOL_PARAM;
				S->symvariable.type = T;
				S->symvariable.pos = 0;
				S->storage = STORE_DATA_STACK;
				push_symbol(S);
			}
			semantic_context = SEMANTIC_PARAM;
				//use new separate symbol table
			struct ast_node *list = ast_get_child(node,1);
			//semantic_analyze(ast_get_child(node,1));
			struct type_name *signature = malloc(sizeof(struct type_name));
			signature->name = 0;
			signature->symclass = 0;
			signature->args = vector2_ptr_type_name_new();
			//parameter as visible from scope VS signature parameter, is confusing.
			int i;
			for(i = 0; i < list->children.size; i++){
				struct ast_node *arg = ast_get_child(list,i);
				struct type_name *T2 = semantic_get_type(ast_get_child(arg,0)->token.value);
				m((*(signature->args)),push_back,T2);
				semantic_analyze(arg);
			}
			S->symfunction.signature = signature;
				//join symbol table to definition
			semantic_context = SEMANTIC_NORMAL;
			//do not get code until imperative pass
			//currentSymbolTable = m(ST_stack,pop_back);
			pop_symbol_table();
			push_symbol(S);
		}else{
			struct symbol *S = lookup_symbol(name);
			if(S->type != SYMBOL_FUNCTION){error("semantic: '%s' is not a function\n",S->username);}
			YYLTYPE pos1 = ast_get_child(node,0)->token.pos;
			YYLTYPE pos2 = ast_get_child(node,1)->token.pos;
			emit_code("/* %s %s(%s) */",get_source_text(pos1.start,pos1.end), name, get_source_text(pos2.start,pos2.end));
			emit_code("LABEL %s",name);		
			push_semantic_context();
			semantic_context = SEMANTIC_NORMAL;
			analyze_scope(ast_get_child(node,2),0,
							&S->symfunction.code,
							&S->symfunction.scope,
							0);
			pop_semantic_context();
			emit_code_segment(S->symfunction.code);
			emit_code("RETURN");
			emit_code("/* end */");
		}
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "var_decl_list")){
		//printf("got var_decl_list\n");
		for(i = 0; i < node->children.size; i++){
			semantic_analyze(ast_get_child(node, i));
		}
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "var_decl")){
		if(!semantic_decl){
		goto semantic_exit;}
		//printf("got var_decl\n");
		struct type_name *T = semantic_get_type(ast_get_child(node,0)->token.value);
		char *name = node->token.value;
		struct symbol *S;// = lookup_symbol_here(name);
		// if(S){
			// error("semantic error: S is already defined");
		// }
		S = new_symbol();
		S->username = name;
		if(semantic_flatten){
			S->IR_name = IR_next_name(name);
		}else{
			S->IR_name = name;
		}
		S->symvariable.type = T;
		if(semantic_context == SEMANTIC_PARAM){
			S->type = SYMBOL_PARAM;
			//S->symparameter.pos = currentSymbolTable->symbols.size;
			S->symvariable.pos = getNumParameters();
			S->storage = STORE_DATA_STACK;
		}else if(semantic_context == SEMANTIC_MEMBER){
			S->type = SYMBOL_MEMBER;
			S->symvariable.pos = getNumMembers();
			S->storage = STORE_DATA_MEMBER;
		}else{
			S->type = SYMBOL_VARIABLE;
			S->symvariable.pos = getNumVariables();
			S->storage = STORE_DATA_STACK;
		}
		push_symbol(S);
		//put into symbol table
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "var_decl_assign")){
		if(!semantic_decl){
		goto semantic_exit;}
		//printf("got var_decl\n");
		struct type_name *T = semantic_get_type(ast_get_child(node,0)->token.value);
		char *name = node->token.value;
		struct symbol *S = new_symbol();
		S->username = name;
		/* if(semantic_flatten){
			S->IR_name = IR_next_name(name);
		}else{
			S->IR_name = name;
		}
		if(semantic_context == SEMANTIC_PARAM){
			S->type = SYMBOL_PARAM;
			S->symparameter.type = T;
			S->symparameter.pos = currentSymbolTable->symbols.size;
		}else{
			S->type = SYMBOL_VARIABLE;
			S->symvariable.type = T;
		} */
		if(semantic_flatten){
			S->IR_name = IR_next_name(name);
		}else{
			S->IR_name = name;
		}
		S->symvariable.type = T;
		if(semantic_context == SEMANTIC_PARAM){
			S->type = SYMBOL_PARAM;
			//S->symparameter.pos = currentSymbolTable->symbols.size;
			S->symvariable.pos = getNumParameters();
			S->storage = STORE_DATA_STACK;
		}else if(semantic_context == SEMANTIC_MEMBER){
			S->type = SYMBOL_MEMBER;
			S->symvariable.pos = getNumMembers();
			S->storage = STORE_DATA_MEMBER;
		}else{
			S->type = SYMBOL_VARIABLE;
			S->symvariable.pos = getNumVariables();
			S->storage = STORE_DATA_STACK;
		}
		push_symbol(S);
		//put into symbol table
		//will deal with assignment later; ignore for now.
		//semantic_analyze(ast_get_child(node,1));
		//put expression as "initial value"?
		
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "stmt_list")){
		//printf("got stmt_list\n");
		for(i = 0; i < node->children.size; i++){
			semantic_analyze(ast_get_child(node, i));
		}
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "stmt")){
		semantic_analyze(ast_get_child(node,0));
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "imp_stmt")){
		if(semantic_decl){goto semantic_exit;}
		//imperative pass: 
		switch(node->token.production){
			case(0)://if_block
				semantic_analyze(ast_get_child(node,0));
				break;
			case(1)://while_loop
				semantic_analyze(ast_get_child(node,0));
				break;
			case(2)://expr
				emit_code("/* %s */",
					get_source_text(node->token.pos.start,
									node->token.pos.end));
				semantic_analyze(ast_get_child(node,0));
				break;
			case(3)://return
				emit_code("/* %s */",
					get_source_text(node->token.pos.start,
									node->token.pos.end));
				emit_code("RETURN");
				break;
			case(4)://return expr
				emit_code("/* %s */",
					get_source_text(node->token.pos.start,
									node->token.pos.end));
				semantic_analyze(ast_get_child(node,0));
				emit_code("RETURN %s",pop_expr());
				break;
			default:
				error("semantic error: unknown switch case");
				break;
		}
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "if_block")){
		//unreachable during semantic_decl
		//imperative pass: 
		const char *CSname;
		switch(node->token.production){
			case(0)://if_then END
				semantic_analyze(ast_get_child(node,0));
				emit_code("/* end */");
				break;
			case(1)://if_then ELSE stmt_list END
				semantic_analyze(ast_get_child(node,0));
				
				emit_code("/* else */");
				struct code_segment *CSinsert;
				analyze_scope(ast_get_child(node,1),0,&CSinsert,0,0);
				emit_code_segment(CSinsert);
				emit_code("/* end if */");
				break;
			default:
				error("semantic error: unknown switch case");
				break;
		}
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "if_then")){
		if(semantic_decl){goto semantic_exit;}
		//imperative pass: 
		//printf("got if_then\n");
		const char *CSname;
		YYLTYPE pos;
		switch(node->token.production){
			case(0): //IF ( expr ) THEN stmt_list
				//(expr)
				pos = ast_get_child(node,0)->token.pos;
				emit_code("/* if(%s) */",get_source_text(pos.start,pos.end));
				struct code_segment *CSinsert;
				analyze_scope(ast_get_child(node,0),0,&CSinsert,0,0);		
				emit_code_segment(CSinsert);
				
				//if then
				const char *nextLabel = IR_next_name("lbl");
				emit_code("IFNOT %s %s", pop_expr(), nextLabel); 
				emit_code("/* then */");
				
				//stmt_list
				analyze_scope(ast_get_child(node,1),0,&CSinsert,0,0);
				emit_code_segment(CSinsert);
				
				//end
				emit_code("LABEL %s", nextLabel);
				break;
			case(2): //if_then ELSEIF ( expr ) THEN stmt_list
				//if_then
				semantic_analyze(ast_get_child(node,0));
				//else if
				YYLTYPE pos = ast_get_child(node,1)->token.pos;
				emit_code("/* else if(%s) */", get_source_text(pos.start,pos.end));
				//( expr )
				analyze_scope(ast_get_child(node,1),0,&CSinsert,0,0);
				emit_code_segment(CSinsert);
				//then
				const char *label1 = IR_next_name("lbl");
				emit_code("IFNOT %s %s", pop_expr(), label1);
				emit_code("/* then */");
				//stmt_list
				analyze_scope(ast_get_child(node,2),0,&CSinsert,0,0);
				emit_code_segment(CSinsert);
				emit_code("LABEL %s", label1);
				break;
			default:
				error("semantic error: unknown switch case");
				break;
		};
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "while_loop")){
		//imperative pass
		YYLTYPE pos1 = ast_get_child(node,0)->token.pos;
		emit_code("/* while(%s) */",get_source_text(pos1.start,pos1.end));
		struct code_segment *CSinsert;
		analyze_scope(ast_get_child(node,0),0,&CSinsert,0,0);
		emit_code_segment(CSinsert);
		emit_code("/* do */");
		const char *label1 = IR_next_name("lbl");
		const char *label2 = IR_next_name("lbl");
		emit_code("LABEL %s",label1);
		emit_code("IFNOT %s %s",pop_expr(), label2);
		analyze_scope(ast_get_child(node,1),0,&CSinsert,0,0);
		emit_code_segment(CSinsert);
		emit_code("GOTO %s",label1);
		emit_code("LABEL %s",label2);
		emit_code("/* end while*/");
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "class_def")){
		if(semantic_decl){
			//printf("got class_def\n");
			char *name = node->token.value;
			struct symbol *S = new_symbol();
			push_symbol(S);
			S->username = name;
			S->storage = STORE_CODE;
			if(semantic_flatten){
				S->IR_name = IR_next_name(name);
			}else{
				S->IR_name = name;
			}
			S->type = SYMBOL_CLASS;
			//make new symbol table
			//struct symbol_table *ST = new_symbol_table();
			push_symbol_table();
			new_symbol_table();
			S->symclass.scope = currentSymbolTable;
			push_semantic_context();
			semantic_context = SEMANTIC_MEMBER;
			symbolThis = S;
			semantic_analyze(ast_get_child(node,0));
			pop_semantic_context();
			class_finalize();
			pop_symbol_table();
			//embed into existing symbol table
			//push_symbol(S);
		}else{
			push_symbol_table();
			char *name = node->token.value;
			semantic_this = "this";
			currentSymbolTable = lookup_symbol(name)->symclass.scope;
			semantic_analyze(ast_get_child(node,0));
			semantic_this = 0;
			pop_symbol_table();
		}
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "expr_list")){
		if(semantic_decl){goto semantic_exit;}
		//imperative pass: 
		//printf("got expr_list\n");
		for(i = 0; i < node->children.size; i++){
			semantic_analyze(ast_get_child(node, i));
			//give name to new expression result?
			//put it in stack?
		}
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "expr_id")){
		//printf("got expr_id = [%s]\n",node->token.value);
		char *name = stralloc(node->token.value);
		struct symbol *S = lookup_symbol(name);
		if((S->type != SYMBOL_VARIABLE)&&(S->type != SYMBOL_PARAM)&&(S->type != SYMBOL_MEMBER)&&(S->type != SYMBOL_FUNCTION)){
			error("semantic: '%s' is not a variable, parameter or function name\n",name);
		}
		struct type_name *T;
		if(S->type == SYMBOL_VARIABLE){
			T = S->symvariable.type;
		}else if(S->type == SYMBOL_PARAM){
			T = S->symvariable.type;
		}else if(S->type == SYMBOL_MEMBER){
			T = S->symvariable.type;
		}else if(S->type == SYMBOL_FUNCTION){
			T = S->symfunction.signature;
		}else{
			YYLTYPE pos = node->token.pos;
			err("line %d: [%s]\n",pos.first_line,get_source_text(pos.start,pos.end));
			error("semantic: '%' is not an expression\n",name);
		}
		printf("found variable '%s' of type '%s'\n",name,T->name);
		//exprResult = name;
		if(semantic_this){
			//const char *result1 = IR_next_name("$reg");
			//emit_code("ADD %s %s %s",result1, semantic_this, S->IR_name);
			char buff[80];
			sprintf(buff,"%s:%s",semantic_this,S->IR_name);
			const char *result1 = stralloc(buff);
			push_expr(result1);
		}else{
			push_expr(S->IR_name);
		}
		push_exprtype(T);
		//put variable <name> on the stack
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "expr_const")){
		//printf("got expr_const\n");
		//char *exprResult = IR_next_name("$reg");
		//sanitize the value, maybe put it somewhere,
		//get pointers, whatever
		struct type_name *T = malloc(sizeof(struct type_name));
		T->symclass = 0;
		T->args = 0;
		YYLTYPE pos;
		switch(node->token.production){
			case(0): //int
				T->name = "int";
			break;
			case(1): //hex int
				T->name = "int";
			break;
			case(2): //binary int
				T->name = "int";
			break;
			case(3): //float
				T->name = "float";
			break;
			case(4): //char
				T->name = "char";
			break;
			case(5): //string
				T->name = "string";
			break;
			default:
				error("semantic error: unknown switch case");
				break;
		};
		//emit_code("MOV %s %s",exprResult, node->token.value);
		//push_expr(exprResult);
		push_expr(node->token.value);
		push_exprtype(T);
		//figure out what kind of const this is?
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "expr_subexpr")){
		//printf("got expr_subexpr\n");
		semantic_analyze(ast_get_child(node,0));
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "expr_call")){
		//printf("got expr_call\n");
		semantic_analyze(ast_get_child(node,0));
		const char *name = pop_expr();
		//struct symbol *S = lookup_symbol_IR(name);
		struct type_name *T = pop_exprtype();//S->symfunction.returntype;
		if(!T->args){
			YYLTYPE pos = node->token.pos;
			err("line %d: [%s]\n",pos.first_line,get_source_text(pos.start,pos.end));
			error("semantic error: attempt to call '%s', which is not a function in this scope\n",name);
		}
		ast_node *list = ast_get_child(node,1);
		int i;
		int len = 0;
		vector2_ptr_char ministack = vector2_ptr_char_here();
		for(i = 0; i < list->children.size; i++){
			semantic_analyze(ast_get_child(list,i));
			const char *expr = pop_expr();
			len += snprintf(0,0,"%s ",expr);
			m(ministack,push_back,expr);
		}
		char *buff = malloc(sizeof(char)*(len+1));
		char *buff2 = buff;
		for(i = 0; i < list->children.size; i++){
			const char *expr = m(ministack,pop_front);
			buff2 = buff2+sprintf(buff2," %s",expr);
		}
		const char *exprResult = IR_next_name("$reg");
		emit_code("CALL %s %s%s",exprResult, name, buff);
		push_expr(exprResult);
		push_exprtype(T);
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "expr_.")){
		if(semantic_decl){goto semantic_exit;}
		//printf("got expr_.\n");
		semantic_analyze(ast_get_child(node,0));
		//what if $0 isn't an ID? need to figure out
		//expression type... also instance... fuck, just redo this.
		struct ast_node *N = ast_get_child(node,0);
		struct type_name *T = pop_exprtype();
		if(!T->symclass){
			YYLTYPE pos = node->token.pos;
			err("line %d: [%s]\n",pos.first_line,get_source_text(pos.start,pos.end));
			error("semantic error: member access (x.y) impossible because x is a primitive (%s)\n",T->name);
		}
		//push_symbol_table(T->symclass->symclass.scope);
		push_symbol_table();
		currentSymbolTable = T->symclass->symclass.scope;
		semantic_this = pop_expr(); 
		semantic_analyze(ast_get_child(node,1));
		semantic_this = 0;
		pop_symbol_table();
		//emit code: member access
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "expr_^")){
		if(semantic_decl){goto semantic_exit;}
		//printf("got expr_^\n");
		semantic_analyze(ast_get_child(node,0));
		semantic_analyze(ast_get_child(node,1));
		const char *result2 = pop_expr();
		const char *result1 = pop_expr();
		const char *exprResult = IR_next_name("$reg");
		emit_code("EXPONENT %s %s %s",exprResult, result1, result2);
		push_expr(exprResult);
		//emit code: exp
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "expr_/")){
		if(semantic_decl){goto semantic_exit;}
		//printf("got expr_/\n");
		semantic_analyze(ast_get_child(node,0));
		semantic_analyze(ast_get_child(node,1));
		const char *result2 = pop_expr();
		const char *result1 = pop_expr();
		const char *exprResult = IR_next_name("$reg");
		emit_code("DIVIDE %s %s %s",exprResult, result1, result2);
		push_expr(exprResult);
		//emit code: div
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "expr_*")){
		if(semantic_decl){goto semantic_exit;}
		//printf("got expr_*\n");
		semantic_analyze(ast_get_child(node,0));
		semantic_analyze(ast_get_child(node,1));
		const char *result2 = pop_expr();
		const char *result1 = pop_expr();
		const char *exprResult = IR_next_name("$reg");
		emit_code("MULTIPLY %s %s %s",exprResult, result1, result2);
		push_expr(exprResult);
		//emit code: mul
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "expr_-")){
		if(semantic_decl){goto semantic_exit;}
		//printf("got expr_-\n");
		semantic_analyze(ast_get_child(node,0));
		semantic_analyze(ast_get_child(node,1));
		const char *result2 = pop_expr();
		const char *result1 = pop_expr();
		const char *exprResult = IR_next_name("$reg");
		emit_code("SUBTRACT %s %s %s",exprResult, result1, result2);
		push_expr(exprResult);
		//emit code: sub
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "expr_+")){
		if(semantic_decl){goto semantic_exit;}
		//printf("got expr_+\n");
		semantic_analyze(ast_get_child(node,0));
		semantic_analyze(ast_get_child(node,1));
		const char *result2 = pop_expr();
		const char *result1 = pop_expr();
		const char *exprResult = IR_next_name("$reg");
		emit_code("ADD %s %s %s",exprResult, result1, result2);
		push_expr(exprResult);
		//emit code: add
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "expr_==")){
		if(semantic_decl){goto semantic_exit;}
		//printf("got expr_+\n");
		semantic_analyze(ast_get_child(node,0));
		semantic_analyze(ast_get_child(node,1));
		const char *result2 = pop_expr();
		const char *result1 = pop_expr();
		const char *exprResult = IR_next_name("$reg");
		emit_code("EQUAL %s %s %s",exprResult, result1, result2);
		push_expr(exprResult);
		//emit code: add
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "expr_!=")){
		if(semantic_decl){goto semantic_exit;}
		//printf("got expr_+\n");
		semantic_analyze(ast_get_child(node,0));
		semantic_analyze(ast_get_child(node,1));
		const char *result2 = pop_expr();
		const char *result1 = pop_expr();
		const char *exprResult = IR_next_name("$reg");
		emit_code("NOTEQUAL %s %s %s",exprResult, result1, result2);
		push_expr(exprResult);
		//emit code: add
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "expr_>")){
		if(semantic_decl){goto semantic_exit;}
		//printf("got expr_+\n");
		semantic_analyze(ast_get_child(node,0));
		semantic_analyze(ast_get_child(node,1));
		const char *result2 = pop_expr();
		const char *result1 = pop_expr();
		const char *exprResult = IR_next_name("$reg");
		emit_code("GREATER %s %s %s",exprResult, result1, result2);
		push_expr(exprResult);
		//emit code: add
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "expr_<")){
		if(semantic_decl){goto semantic_exit;}
		//printf("got expr_+\n");
		semantic_analyze(ast_get_child(node,0));
		semantic_analyze(ast_get_child(node,1));
		const char *result2 = pop_expr();
		const char *result1 = pop_expr();
		const char *exprResult = IR_next_name("$reg");
		emit_code("LESS %s %s %s",exprResult, result1, result2);
		push_expr(exprResult);
		//emit code: add
		goto semantic_exit;
	}
	if(!strcmp(node->token.type, "expr_=")){
		if(semantic_decl){goto semantic_exit;}
		//printf("got expr_=\n");
		semantic_analyze(ast_get_child(node,0));
		semantic_analyze(ast_get_child(node,1));
		const char *result2 = pop_expr();
		const char *result1 = pop_expr();
		emit_code("MOV %s %s", result1, result2);
		push_expr(result1);
		//emit code: assign
		goto semantic_exit;
	}
	//unknown node type
	YYLTYPE pos = node->token.pos;
	err("line %d: [%s]\n",pos.first_line,get_source_text(pos.start,pos.end));
	error("semantic: unknown node type: [%s]\n",node->token.type);
	semantic_exit:
	semantic_analyze_pad--;
	//printmemory(stdout);
	return;
}

void semantic_finalize(){
	currentSymbolTable = m(ST_list,get,0);
	struct symbol *M = lookup_symbol("main");
	if((!M)||(M->type != SYMBOL_FUNCTION)){
		error("semantic error: missing function main()\n");
	}
	if(semantic_flatten){
		currentCodeSegment = m(CS_list,get,0);
		int i;
		for(i = 0; i < CS_list.size; i++){
			struct code_segment *CS = m(CS_list,get,i);
			if(CS != currentCodeSegment){
				emit_code_segment(CS);
			}
		}
		m(CS_list,clear);
		m(CS_list,push_back,currentCodeSegment);
		currentSymbolTable = M->symfunction.scope;
		while(currentSymbolTable->parent){currentSymbolTable = currentSymbolTable->parent;}
		for(i = 0; i < ST_list.size; i++){
			struct symbol_table *ST = m(ST_list,get,i);
			if(ST != currentSymbolTable){
				int j;
				for(j = 0; j < ST->symbols.size; j++){
					push_symbol(m(ST->symbols,get,j));
				}
			}
		}
		m(ST_list,clear);
		m(ST_list,push_back,currentSymbolTable);
	}
}

void class_finalize(){
	int i;
	int constructor_found = 0;
	int destructor_found = 0;
	for(i = 0; i < currentSymbolTable->symbols.size; i++){
		struct symbol *S = m(currentSymbolTable->symbols,get,i);
		if(!strcmp(S->username,"constructor")){constructor_found = 1;}
		if(!strcmp(S->username,"destructor")){destructor_found = 1;}
	}
	if(!constructor_found){
		struct symbol *S = new_symbol();
		push_symbol(S);
		push_symbol_table();
		struct symbol_table *ST = currentSymbolTable;
		new_symbol_table();
		push_code_segment();
		new_code_segment();
		const char *name = "constructor";
		const char *IR_name = IR_next_name(name);
		S->type = SYMBOL_FUNCTION;
		//S->storage = STORE_CODE;
		S->username = name;
		S->IR_name = IR_name;
		S->symfunction.returntype = semantic_get_type("void");
		S->symfunction.code = currentCodeSegment;
		S->symfunction.scope = currentSymbolTable;
		
		currentSymbolTable = ST;
		emit_code("/* default class constructor */");
		emit_code("LABEL %s",IR_name);
		emit_all_initializers();
		emit_code("/* end */");
		
		pop_code_segment();
		pop_symbol_table();
	}
	if(!destructor_found){
		struct symbol *S = new_symbol();
		push_symbol(S);
		push_symbol_table();
		struct symbol_table *ST = currentSymbolTable;
		new_symbol_table();
		push_code_segment();
		new_code_segment();
		const char *name = "destructor";
		const char *IR_name = IR_next_name(name);
		S->type = SYMBOL_FUNCTION;
		S->username = name;
		S->IR_name = IR_name;
		S->symfunction.returntype = semantic_get_type("void");
		S->symfunction.code = currentCodeSegment;
		S->symfunction.scope = currentSymbolTable;
		
		currentSymbolTable = ST;
		emit_code("/* default class destructor */");
		emit_code("LABEL %s",IR_name);
		emit_all_deinitializers();
		emit_code("/* end */");
		
		pop_code_segment();
		pop_symbol_table();
	}
}
void emit_all_initializers(){
	int i = 0;
	for(i = 0; i < currentSymbolTable->symbols.size; i++){
		struct symbol *S = m(currentSymbolTable->symbols,get,i);
		if(S->type == SYMBOL_VARIABLE){emit_initializer(S);}
	}
}
void emit_initializer(struct symbol *S){
	struct type_name *T = S->symvariable.type;
	if(T->symclass){
		emit_code("/* construct %s */",S->username);
		struct symbol *S2 = T->symclass;
		push_symbol_table();
		currentSymbolTable = S2->symclass.scope;
		struct symbol *S3 = lookup_symbol("constructor");
		const char *exprResult = IR_next_name("$reg");
		emit_code("CALL %s %s %s",exprResult,S3->IR_name,S->IR_name);
		pop_symbol_table();
	}else{
		//primitive type
		emit_code("/* initialize %s */",S->username);
		emit_code("MOV %s 0",S->IR_name);
	}
}
void emit_all_deinitializers(){
	int i = 0;
	for(i = 0; i < currentSymbolTable->symbols.size; i++){
		struct symbol *S = m(currentSymbolTable->symbols,get,i);
		if(S->type == SYMBOL_VARIABLE){emit_deinitializer(S);}
	}
}
void emit_deinitializer(struct symbol *S){
	struct type_name *T = S->symvariable.type;
	if(T->symclass){
		emit_code("/* destroy %s */",S->username);
		struct symbol *S2 = T->symclass;
		push_symbol_table();
		currentSymbolTable = S2->symclass.scope;
		struct symbol *S3 = lookup_symbol("destructor");
		const char *exprResult = IR_next_name("$reg");
		emit_code("CALL %s %s %s",exprResult,S3->IR_name,S->IR_name);
		pop_symbol_table();
	}else{
		//primitive type
		//do nothing
		//emit_code("MOV %s 0",S->IR_name);
	}
}
void new_symbol_table(){
	struct symbol_table *T = malloc(sizeof(struct symbol_table));
	T->name = IR_next_name("ST");
	T->symbols = vector2_ptr_symbol_here();
	//vector_constructor(&T->symbols,sizeof(struct symbol));
	T->parent = currentSymbolTable;
	m(ST_list,push_back,T);
	currentSymbolTable = T;
}

void push_symbol_table(){
	m(ST_stack,push_back,currentSymbolTable);
}

void pop_symbol_table(){
	currentSymbolTable = m(ST_stack,pop_back);
}
// struct symbol_table *new_symbol_table_make_current(){
	// struct symbol_table *ST = new_symbol_table();
	// push_symbol_table(ST);
	// return ST;
// }
// struct symbol_table *new_symbol_table_make_current_standalone(){
	// struct symbol_table *ST = new_symbol_table_make_current();
	// m(ST_stack,push_front,ST);
	// return ST;
// }
// void push_symbol_table(){
	// m(ST_stack,push_back,currentSymbolTable);
// }
// void pop_symbol_table(){
	// currentSymbolTable = m(ST_stack,pop_back);//vector_pop_back(&ST_stack);
// }

struct symbol *lookup_symbol_helper(const char *name, struct symbol_table *T){
	int i;
	for(i = 0; i < T->symbols.size; i++){
		struct symbol *S;
		//S = vector_get_reference(&T->symbols, i);
		S = m(T->symbols,get,i);
		if(!strcmp(S->username,name)){
			printf("found symbol '%s'->'%s'\n",name,T->name);
			return S;
		}
	}
	if(T->parent){
		return lookup_symbol_helper(name, T->parent);
	}else{
		return 0;
	}
}

struct symbol *lookup_symbol(const char *name){
	struct symbol *S = lookup_symbol_helper(name, currentSymbolTable);
	if(S){
		return S;
	}else{
		//printf("SEMANTIC ERROR. printing semantic info so far:\n");
		//print_semantic();
		error("semantic error: undefined symbol '%s'->'%s'\n",name,currentSymbolTable->name);
		return 0;
	}	
}
struct symbol *lookup_symbol_IR_helper(const char *name, struct symbol_table *T){
	int i;
	for(i = 0; i < T->symbols.size; i++){
		struct symbol *S;
		//S = vector_get_reference(&T->symbols, i);
		S = m(T->symbols,get,i);
		if(!strcmp(S->IR_name,name)){
			printf("found symbol '%s'->'%s'\n",name,T->name);
			return S;
		}
	}
	if(T->parent){
		return lookup_symbol_IR_helper(name, T->parent);
	}else{
		return 0;
	}
}
struct symbol *lookup_symbol_IR(const char *name){
	struct symbol *S = lookup_symbol_IR_helper(name, currentSymbolTable);
	if(S){
		return S;
	}else{
		//printf("SEMANTIC ERROR. printing semantic info so far:\n");
		//print_semantic();
		error("semantic error: undefined IR symbol '%s'->'%s'\n",name,currentSymbolTable->name);
		return 0;
	}	
}
void new_code_segment(){
	struct code_segment *CS = malloc(sizeof(struct code_segment));
	CS->name = IR_next_name("CS");
	CS->scope = currentSymbolTable;
	//vector_constructor(&CS->commands,sizeof(char*));
	CS->commands = vector2_ptr_char_here();
	CS->indent = CS_stack.size;
	m(CS_list,push_back,CS);
	currentCodeSegment = CS;
}

void push_code_segment(){
	m(CS_stack,push_back,currentCodeSegment);
}

void pop_code_segment(){
	currentCodeSegment = m(CS_stack,pop_back);
}
void analyze_scope(struct ast_node *N, 
					struct code_segment **CSin,
					struct code_segment **CSout,
					struct symbol_table **STin,
					struct symbol_table **STout){
	push_symbol_table();
	if(STin){currentSymbolTable = *STin;}
	else{
		new_symbol_table();
	}
	if(STout){*STout = currentSymbolTable;}
	push_code_segment();
	if(CSin){currentCodeSegment = *CSin;}
	else{
		new_code_segment();
	}
	if(CSout){*CSout = currentCodeSegment;}
	semantic_decl = 1;
	semantic_analyze(N);
	semantic_decl = 0;
	emit_all_initializers();
	semantic_analyze(N);
	emit_all_deinitializers();
	pop_code_segment();
	pop_symbol_table();
}
/* struct code_segment *new_code_segment_make_current(){
	struct code_segment *CS = new_code_segment();
	push_code_segment(CS);
	return CS;
}
struct code_segment *new_code_segment_make_current_standalone(){
	struct code_segment *CS = new_code_segment_make_current();
	m(CS_stack,push_front,CS);
	return CS;
}
void push_code_segment(struct code_segment *CS){
	//vector_push_back(&CS_stack, currentCodeSegment);
	if(currentCodeSegment){
		m(CS_stack,push_back,currentCodeSegment);
	}
	currentCodeSegment = CS;
}

void pop_code_segment(){
	if(CS_stack.size){
		currentCodeSegment = m(CS_stack,pop_back);//vector_pop_back(&CS_stack);
	}
} */
struct symbol *new_symbol(){
	struct symbol *S = malloc(sizeof(struct symbol));
	S->type = SYMBOL_ERROR;
	//S->storage = STORE_ERROR;
	S->username = 0;
	S->IR_name = 0;
}

void push_symbol(struct symbol *S){
	//vector_push_back(&currentSymbolTable->symbols, &S);
	m(currentSymbolTable->symbols,push_back,S);
}

struct type_name *semantic_get_type(const char *str){
	struct type_name *T = malloc(sizeof(struct type_name));
	T->args = 0;
	T->pointerlevel = 0;
	if(!strcmp(str, "int")){
		T->name = "int";
		T->symclass = 0;
		return T;
	}
	if(!strcmp(str, "float")){
		T->name = "float";
		T->symclass = 0;
		return T;
	}
	if(!strcmp(str, "char")){
		T->name = "char";
		T->symclass = 0;
		return T;
	}
	if(!strcmp(str, "string")){
		T->name = "string";
		T->symclass = 0;
		return T;
	}
	if(!strcmp(str, "void")){
		T->name = "void";
		T->symclass = 0;
		return T;
	}
	struct symbol *S = lookup_symbol(str);
	if(!S){error("semantic error: unknown type [%s]\n",S);}
	T->name = S->username; //IR name here maybe?
	T->symclass = S;
	return T;
}
void padprint(int indent){
	while(indent--){
		printf(" ");
	}
}

/* const char *storageToString(struct symbol::storage storage){
	switch(S->storage){
		case(STORE_CODE):
			storage = "code";
			break;
		case(STORE_DATA_DYNAMIC):
			storage = "dynamic";
			break;
		case(STORE_DATA_STATIC):
			storage = "static";
			break;
		case(STORE_DATA_STACK):
			storage = "stack";
			break;
		case(STORE_DATA_MEMBER):
			storage = "member";
			break;
		default:
			error("semantic error: unknown storage class");
			break;
		};
} */

/*switch(S->type){
			case(SYMBOL_VARIABLE):
				symbol = "variable";
				type = S->symvariable.type->name;
			break;
			case(SYMBOL_MEMBER):
				symbol = "member";
				type = S->symvariable.type->name;
			break;
			case(SYMBOL_PARAM):
				symbol = "parameter";
				type = S->symparameter.type->name;
				pos = malloc(snprintf(0,0,"%d",S->symparameter.pos));
				sprintf(pos,"%d",S->symparameter.pos);
			break;
			case(SYMBOL_FUNCTION):
				symbol = "function";
				type = S->symfunction.returntype->name;
				scope = S->symfunction.scope->name;
				code = S->symfunction.code->name;
			break;
			case(SYMBOL_CLASS):
				symbol = "class";
				scope = S->symclass.scope->name;
			break;
			default:
				error("semantic error: unknown switch case");
				break;
		};*/
void print_symbol_table_helper_short(struct symbol_table *T, int indent){
	padprint(indent);
	if(!T->parent){
		printf("Symbol table '%s':\n", T->name);
	}else{
		printf("Symbol table '%s'->'%s':\n", T->name,T->parent->name);
	}
	const char *symbol;
	const char *name;
	const char *ir_name;
	//const char *storage;
	const char *type;
	const char *scope;
	const char *code;
	char *pos;
	//printf("symbol\tname\tir_name\ttype\tscope\tcode\tpos\n");
	int i;
	int j;
	for(j = 0; j < T->symbols.size; j++){
		struct symbol *S2 = m(T->symbols,get,j);
		if(S2->type == SYMBOL_CLASS){
			printf("classes:\n");
			printf("name\tir_name\tscope\n");
			for(i = 0; i < T->symbols.size; i++){
				struct symbol *S = m(T->symbols,get,i);
				if(S->type == SYMBOL_CLASS){
					printf("%s\t%s\t%s\n",S->username,S->IR_name,S->symclass.scope->name);
				}
			}
		break;
		}
	}
	
	
	for(j = 0; j < T->symbols.size; j++){
		struct symbol *S2 = m(T->symbols,get,j);
		if(S2->type == SYMBOL_FUNCTION){
			printf("functions:\n");
			printf("type\tname\tir_name\tscope\tcode\n");
			for(i = 0; i < T->symbols.size; i++){
				struct symbol *S = m(T->symbols,get,i);
				if(S->type == SYMBOL_FUNCTION){
					printf("%s\t%s\t%s\t%s\t%s\n",S->symfunction.returntype->name,S->username,S->IR_name,S->symfunction.scope->name,S->symfunction.code->name);
				}
			}
		break;
		}
	}
	
	
	for(j = 0; j < T->symbols.size; j++){
		struct symbol *S2 = m(T->symbols,get,j);
		if(S2->type == SYMBOL_PARAM){
			printf("parameters:\n");
			printf("type\tname\tir_name\tsize\tpos\n");
			for(i = 0; i < T->symbols.size; i++){
				struct symbol *S = m(T->symbols,get,i);
				if(S->type == SYMBOL_PARAM){
					printf("%s\t%s\t%s\t%d\t%d\n",S->symvariable.type->name,S->username,S->IR_name,S->symvariable.size,S->symvariable.pos);
				}
			}
		break;
		}
	}
	
	
	for(j = 0; j < T->symbols.size; j++){
		struct symbol *S2 = m(T->symbols,get,j);
		if(S2->type == SYMBOL_MEMBER){
			printf("members:\n");
			printf("type\tname\tir_name\tsize\tpos\n");
			for(i = 0; i < T->symbols.size; i++){
				struct symbol *S = m(T->symbols,get,i);
				if(S->type == SYMBOL_MEMBER){
					printf("%s\t%s\t%s\t%d\t%d\n",S->symvariable.type->name,S->username,S->IR_name,S->symvariable.size,S->symvariable.pos);
				}
			}
		break;
		}
	}
	
	
	for(j = 0; j < T->symbols.size; j++){
		struct symbol *S2 = m(T->symbols,get,j);
		if(S2->type == SYMBOL_VARIABLE){
			printf("variables:\n");
			printf("type\tname\tir_name\tsize\tpos\n");
			for(i = 0; i < T->symbols.size; i++){
				struct symbol *S = m(T->symbols,get,i);
				if(S->type == SYMBOL_VARIABLE){
					printf("%s\t%s\t%s\t%d\t%d\n",S->symvariable.type->name,S->username,S->IR_name,S->symvariable.size,S->symvariable.pos);
				}
			}
		break;
		}
	}
	//printf("symbol\tname\tir_name\ttype\tscope\tcode");
	/* for(i = 0; i < T->symbols.size; i++){
		name = ir_name = type = scope = code = pos = "";
		struct symbol *S = m(T->symbols,get,i);
		name = S->username;
		ir_name = S->IR_name;
		storage = storageToString(S->storage);
		
		printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\n",symbol,name,ir_name,type,scope,code,pos);
	} */
}
void print_symbol_table_helper(struct symbol_table *T, int indent){
	padprint(indent); 
	if(!T->parent){
		printf("Symbol table '%s':\n", T->name);
	}else{
		printf("Symbol table '%s'->'%s':\n", T->name,T->parent->name);
	}
	int i;
	for(i = 0; i < T->symbols.size; i++){
		struct symbol *S = m(T->symbols,get,i);//vector_get_reference(&T->symbols,i);
		padprint(indent); printf("symbol [%s]: ",S->username);
		switch(S->type){
			case(SYMBOL_VARIABLE):
				printf("variable\n");
				padprint(indent); printf(" IR_name = %s\n",S->IR_name);
				padprint(indent); printf(" type = %s\n", S->symvariable.type->name);
			break;
			case(SYMBOL_PARAM):
				printf("parameter\n");
				padprint(indent); printf(" IR_name = %s\n",S->IR_name);
				padprint(indent); printf(" type = %s\n", S->symvariable.type->name);
				padprint(indent); printf(" pos = %d\n", S->symvariable.pos);
			break;
			case(SYMBOL_FUNCTION):
				printf("function\n");
				padprint(indent); printf(" IR_name = %s\n",S->IR_name);
				padprint(indent); printf(" return type = %s\n", S->symfunction.returntype->name);
				padprint(indent); printf(" scope = %s\n", S->symfunction.scope->name);
				padprint(indent); printf(" code = %s\n", S->symfunction.code->name);
				//print_symbol_table_helper(S->symfunction.scope, indent+1);
			break;
			case(SYMBOL_CLASS):
				printf("class\n");
				padprint(indent); printf(" IR_name = %s\n",S->IR_name);
				padprint(indent); printf(" scope = %s\n", S->symclass.scope->name);
				//print_symbol_table_helper(S->symclass.scope,indent+1);
			break;
			default:
				error("semantic error: unknown switch case");
				break;
		};
	}
	padprint(indent); printf("End Symbol table\n");
}
void print_symbol_table(struct symbol_table *T){
	print_symbol_table_helper_short(T,0);
}
void print_code_segment(struct code_segment *CS){
	printf("code segment '%s'->'%s'\n",CS->name,CS->scope->name);
	int i;
	for(i = 0; i < CS->commands.size; i++){
		printf(" %s\n",m(CS->commands,get,i));
	}
	printf("end code segment\n");
}

vector2_ptr_char IR_names;
vector2_int IR_namecounts;
void IR_init(){
	IR_names = vector2_ptr_char_here();
	IR_namecounts = vector2_int_here();
	//vector_constructor(&IR_names,sizeof(char*));
	//vector_constructor(&IR_namecounts,sizeof(int));
}
char *stralloc(const char *str);
char *IR_next_name(const char *prefix){
	int i;
	int count;
	for(i = 0; i < IR_names.size; i++){
		//char *str = *(char**)vector_get_copy(&IR_names,i);
		const char *str = m(IR_names,get,i);
		if(!strcmp(str,prefix)){
			//int *count = (int*)vector_get_reference(&IR_namecounts,i);
			goto IR_next_name_found;
		}
	}	
	const char *newprefix = stralloc(prefix);
	//int z = 0;
	m(IR_names,push_back,newprefix);
	m(IR_namecounts,push_back,0);
	//vector_push_back(&IR_names,&newprefix);
	//vector_push_back(&IR_namecounts,&z);
	//count = (int*)vector_get_reference(&IR_namecounts,IR_namecounts.size-1);
IR_next_name_found:
	count = m(IR_namecounts,get,i);
	count++;
	m(IR_namecounts,set,count,i);
	//*count = *count+1;
	char *buff;
	int len = snprintf(buff, 0, "%s$%d",prefix,count);
	buff = malloc(sizeof(char)*(len+1));
	sprintf(buff, "%s$%d",prefix,count);
	printf("IR_next_name: returning [%s]\n",buff);
	return buff;
}
int emit_code_pad = 0;
void emit_code(const char *fmt, ...){
	if(!currentCodeSegment){error("emit_code: no code segment\n");}
	va_list ap;
	va_start(ap, fmt);
	char *buff;
	int len = vsnprintf(buff,0,fmt,ap);
	emit_code_pad = currentCodeSegment->indent;
	buff = malloc(sizeof(char)*(len+1+emit_code_pad));
	va_end(ap);
	va_start(ap, fmt);
	int i;
	for(i = 0; i < emit_code_pad; i++){
		sprintf(buff+i," ");
	}
	vsprintf(buff+emit_code_pad,fmt,ap);
	va_end(ap);
	//vector_push_back(&currentCodeSegment->commands,&buff);
	m(currentCodeSegment->commands,push_back,buff);
}
void emit_code_segment(struct code_segment *CS){
	if(!CS){error("emit_code_segment: no CS\n");}
	if(semantic_flatten){
		printf("emitting code segment %s\n",CS->name);
		int i;
		for(i = 0; i < CS->commands.size; i++){
			emit_code(m(CS->commands,get,i));
		}
		m(CS_list,pop_back);
	}else{
		emit_code("INSERT %s", CS->name);
	}
}
void push_expr(const char *expr){
	//vector_push_back(&expr_stack, &expr);
	m(expr_stack,push_back,expr);
}
const char *pop_expr(){
	return m(expr_stack,pop_back);//vector_pop_back(&expr_stack);
}
void push_exprtype(struct type_name *T){
	m(exprtype_stack,push_back,T);
}
struct type_name *pop_exprtype(){
	return m(exprtype_stack,pop_back);
}
void semantic_init(){
	IR_init();
	expr_stack = vector2_ptr_char_here();
	exprtype_stack = vector2_ptr_type_name_here();
	CS_stack = vector2_ptr_code_segment_here();
	CS_list = vector2_ptr_code_segment_here();
	ST_stack = vector2_ptr_symbol_table_here();
	ST_list = vector2_ptr_symbol_table_here();
	IR_names = vector2_ptr_char_here();
	IR_namecounts = vector2_int_here();
	semantic_context_stack = vector2_ptr_semantic_context_kind_here();
	//vector_constructor(&expr_stack, sizeof(char*));
	//vector_constructor(&CS_stack, sizeof(struct code_segment));
	//vector_constructor(&ST_stack, sizeof(struct symbol_table));
	//vector_constructor(&IR_names, sizeof(char *));
	//vector_constructor(&IR_namecounts, sizeof(int*));
	//currentCodeSegment = 0;
	//currentSymbolTable = 0;
}
void print_semantic(){
	printf("printing symbol tables (%d):\n",ST_list.size);
	int i;
	for(i = 0; i < ST_list.size; i++){
		print_symbol_table(m(ST_list,get,i));
	}
	printf("printing code segments (%d):\n",CS_list.size);
	for(i = 0; i < CS_list.size; i++){
		print_code_segment(m(CS_list,get,i));
	}
}
int getNumParameters(){
	int N = 0;
	int I;
	for(I = 0; I < currentSymbolTable->symbols.size; I++){
		ptr_symbol S = m(currentSymbolTable->symbols,get,I);
		if(S->type == SYMBOL_PARAM){N++;}
	}
	return N;
}
int getNumMembers(){
	int N = 0;
	int I;
	for(I = 0; I < currentSymbolTable->symbols.size; I++){
		ptr_symbol S = m(currentSymbolTable->symbols,get,I);
		if(S->type == SYMBOL_MEMBER){N++;}
	}
	return N;
}
int getNumVariables(){
	int N = 0;
	int I;
	for(I = 0; I < currentSymbolTable->symbols.size; I++){
		ptr_symbol S = m(currentSymbolTable->symbols,get,I);
		if(S->type == SYMBOL_VARIABLE){N++;}
	}
	return N;
}

#define MAX_ALLOCS 2000
void *allocs[MAX_ALLOCS];
int allocsizes[MAX_ALLOCS];
const char *allocfiles[MAX_ALLOCS];
const char *allocfuncs[MAX_ALLOCS];
int alloclines[MAX_ALLOCS];
int memused;
int numallocs;
#define BUMP_MAX 1000000
char bump_buff[BUMP_MAX];
int bump_free;
void initallocs(){
	memused = 0;
	numallocs = 0;
	int i;
	for(i = 0; i < 2000; i++){
		allocs[i] = 0;
	}
	for(i = 0; i < 2000; i++){
		allocsizes[i] = 0;
	}
	for(i = 0; i < 2000; i++){
		allocfiles[i] = 0;
	}
	for(i = 0; i < 2000; i++){
		allocfuncs[i] = 0;
	}
	for(i = 0; i < 2000; i++){
		alloclines[i] = 0;
	}
	bump_free = 0;
}
void *bumpalloc(size_t size){
	if((bump_free+size+2*sizeof(int))<BUMP_MAX){		
		void *result = (void*)(bump_buff+bump_free+2*sizeof(int));
		bump_free+=size+2*sizeof(int);
		((int*)result)[-1]=size;
		printf("bump %d bytes: %d bytes left\n", size, BUMP_MAX-bump_free);
		return result;
	}else{
		return 0;
	}
}
void *bumprlloc(void *ptr, size_t size){
	if(ptr){
		void *result = bumpalloc(size);
		memcpy(result,ptr,((int*)ptr)[-1]);
		return result;
	}else{return bumpalloc(size);}
}
void *newmalloc(size_t size, void *(oldmalloc)(size_t size), const char* file, const char* func, int line){
	err("info: malloc(%d)",size);
	err("@ file \"%s\", line %d, func \"%s\"\n",file,line,func);
	#ifdef BUMP_ALLOCATOR
	void *m = bumpalloc(size);
	#else
	void *m = oldmalloc(size);
	#endif
	if(!m){
		err("newmalloc: malloc(%d) failed\n",size);
		err("@ file \"%s\", line %d, func \"%s\"\n",file,line,func);
	}
	else{
		allocs[numallocs] = m;
		allocsizes[numallocs] = size;
		allocfiles[numallocs] = file;
		allocfuncs[numallocs] = func;
		alloclines[numallocs] = line;
		numallocs++;
		memused += size;
	}
	return m;
}
void *newrealloc(void *ptr, size_t size, void *(oldrealloc)(void *ptr, size_t size), const char* file, const char* func, int line){
	err("info: reallocalloc(%p, %d)",ptr, size);
	int i = 0;
	int found = 0;
	if(ptr){
		for(i = 0; i < 2000; i++){
			if(allocs[i] == ptr){found = 1; break;}
		}
		if(!found){
			err("newrealloc: attempt to realloc(%p,%d): bad pointer\n",ptr,size);
			error("@ file \"%s\", line %d, func \"%s\"\n",file,line,func);
	
		}
	}
	#ifdef BUMP_ALLOCATOR
	void *m = bumprlloc(ptr, size);
	#else
	void *m = oldrealloc(ptr, size);
	#endif
	if(m){
		if(found){
			err("info: old size = %d\n",allocsizes[i]);
			memused -= allocsizes[i];
			memused += size;
			allocsizes[i] = size;
			allocs[i] = m;
		}else{
			err("info: new allocation\n");
			allocs[numallocs] = m;
			allocsizes[numallocs] = size;
			allocfiles[numallocs] = file;
			allocfuncs[numallocs] = func;
			alloclines[numallocs] = line;
			numallocs++;
			memused += size;
		}
	}else{
		err("newrealloc: realloc(%p,%d) failed\n",ptr,size);
		err("@ file \"%s\", line %d, func \"%s\"\n",file,line,func);
	}
	err("@ file \"%s\", line %d, func \"%s\"\n",file,line,func);
	return m;
}
void newfree(void *ptr, const char *file, const char* func, int line, void (oldfree)(void *ptr)){
	err("info: free(%p)\n",ptr);
	int i = 0;
	int found = 0;
	if(ptr){
		for(i = 0; i < 2000; i++){
			if(allocs[i] == ptr){found = 1; break;}
		}
		if(!found){
			err("newfree: free(%d): bad pointer\n",ptr);
			error("@ file \"%s\", line %d, func \"%s\"\n",file,line,func);
		}
		err("info: old size = %d\n",allocsizes[i]);
		allocs[i] = 0;
		allocsizes[i] = 0;
		allocfiles[i] = 0;
		alloclines[i] = 0;
		allocfuncs[i] = 0;
	}else{
		err("note: free(0)\n");
		err("@ file \"%s\", line %d, func \"%s\"\n",file,line,func);
	}
	//oldfree(ptr);
	err("@ file \"%s\", line %d, func \"%s\"\n",file,line,func);
}
void printmemory(FILE *fp){
	fprintf(fp, "num allocs: %d, mem used: %d\n", numallocs, memused);
}
void printallocs(FILE *fp){
	int i;
	for(i = 0; i < 2000; i++){
		if(allocs[i]){
			fprintf(fp, "alloc(%d)\t=\t%p\tfrom file \"%s\"\tline %d,\tfunc \"%s\"\n", allocsizes[i],allocs[i],allocfiles[i],alloclines[i],allocfuncs[i]);
		}
	}
}
void newerror(const char *file, int line, const char *func, const char *fmt, ...){
	//va_list ap;
	//va_start(ap, fmt);
	//char *buff;
	//int len = vsnprintf(buff,0,fmt,ap);
	//buff = malloc(sizeof(char)*(len+1));
	//va_end(ap);
	//va_start(ap, fmt);
	//vsnprintf(buff,len,fmt,ap);
	//va_end(ap);
	fprintf(stderr, "\n");
	va_list ap;
	va_start(ap, fmt);
	vfprintf(stderr, fmt, ap);
	err("@ file \"%s\", line %d, func \"%s\"\n",file,line,func);
	va_end(ap);
	//err("error: printing allocations:\n");
	printmemory(stderr);
	//printallocs(stderr);
	err("error: activating self-destruct\n");
	
	fprintf(stdout, "\n");
	va_start(ap, fmt);
	vfprintf(stdout, fmt, ap);
	fprintf(stdout, "@ file \"%s\", line %d, func \"%s\"\n",file,line,func);
	va_end(ap);
	
	exit(*(int*)0);
}