//there are infinite registers r1-r9999
//they may be reused, code-gen will figure out actual
//assignments
SYMBOL	__pcv_printf
DATA_SEGMENT	DS1
str1	cstr	"hello world\n"
str2	cstr	"%d\n"	
const1	float64	521.123
CODE_SEGMENT	CS1
r1	=	ADD	str1	5
r1	=	READ r1
r1	=	CALL class_A_foo r1
r1	=	ADD r1	3
r1(	str1	const1	const2 )
RETURN
CODE_SEGMENT	CS2
r1	=	ADD	fp	3
r1	=	STACK_GET r1
cs2_loop:
IF r1	THEN	cs2_loop_end
r1	=	SUB r1	1
__pcv_printf( str2 r1 )
GOTO cs2_loop
cs2_loop_end
RETURN

/*
allowed directives
SYMBOL <name> // <name> will be filled in by the linker
DATA_SEGMENT <name> //the following code goes into the 
					//r!w!x data segment <name>
CODE_SEGMENT <name> //the following code goes into the
					//!r!wx code segment <name>
VARIABLE_SEGMENT <name> //the following code goes into the
						//rw!x data segment <name>
<reg> = ADD <val1> <val2>
<reg> = SUB <val1> <val2>
<reg> = MUL <val1> <val2>
<reg> = DIV <val1> <val2>
<reg> = READ <val>	//read memory at <val>
<val> = WRITE <val>	//write to memory at first <val>
<val> ( <val> ... ) //call the function at address <val> 
					//with several arguments <val>...
IF <val> THEN <label> //if condition, jump to label
RETURN				//return from call
<name>:				//define label <name>


current IR:

LABEL <name>
RET
alloc <val> <size> stack
<comment>
<code segment>
JNE <val> <val> <label>
JMP <label>
<val> = add <val> <val>
<val> = call <val/label> {<val>}
<val> = exponent <val> <val>
<val> = divide <val> <val>
<val> = multiply <val> <val>
<val> = subtract <val> <val>
	add
	equal
	notequal
	greater
	less
<val> = <val>
insert <cs>
....
LABEL(1)
RET
RET(0)
JMP_L,_E,_G,_LE,_GE,_NE(3)
JMP(1)
CALL(1+)
MOV(2)
MATH <val result> <val op1> <val op2>:add,sub,mul,div,exp,equal,notequal,greater,less
ASM(...)
ALLOC STACK(2)
INSERT(1)


in the future - AST into AST_imperative_annotated:
CS
-symbol table
 -symbol_var
 -symbol_member
 -symbol_func
 -symbol_class
-commands
 -init var
 -expression
  -expression